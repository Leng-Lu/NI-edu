
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Statistics with Nilearn &#8212; NI-edu</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Experimental design and pattern estimation" href="../../fMRI-pattern-analysis/week_1/design_and_pattern_estimation.html" />
    <link rel="prev" title="An introduction to Nilearn" href="nilearn.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/fmri.gif" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">NI-edu</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Welcome to NI-edu
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/about.html">
   About this course
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/installation.html">
   Installation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  fMRI-introduction
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/1_python.html">
   Python for (f)MRI analysis
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../other/python_recap.html">
     Python recap
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_1/python_for_mri.html">
     Working with MRI data in Python (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/2_glm.html">
   Using the GLM to model fMRI data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_2/glm_part1_estimation.html">
     The GLM: estimation (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/glm_part2_inference.html">
     The GLM: inference (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/3_design_of_experiments_T.html">
   Design of experiments
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/design_of_experiments.html">
     Design of experiments (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_3/neurodesign.html">
     Neurodesign (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/4_preprocessing.html">
   Preprocessing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_4/temporal_preprocessing.html">
     Temporal preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_4/spatial_preprocessing.html">
     Spatial preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_4/fmriprep.html">
     Fmriprep (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/5_multilevel.html">
   First &amp; run-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/linux_and_the_command_line.html">
     Linux and the CMD (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/first_level_analyses.html">
     First level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_5/run_level_analyses.html">
     Run-level analyses (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/6_grouplevel.html">
   Group-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/group_level_analyses.html">
     Group-level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/MCC.html">
     Multiple comparison correction (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../week_6/ROI_analysis.html">
     ROI analysis (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../../section_intros/7_nilearn.html">
   Introduction to Nilearn
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="nilearn.html">
     Introduction to Nilearn (T)
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Statistics with Nilearn (T)
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  fMRI-pattern-analysis
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_1/design_and_pattern_estimation.html">
   Design and pattern estimation (T)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_2/decoding_analyses.html">
   Machine learning/decoding (T)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../fMRI-pattern-analysis/week_3/rsa.html">
   Representational Similarity Analysis (T)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Misc
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/bibliography.html">
   Bibliography
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/for_educators.html">
   For educators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONTRIBUTING.html">
   Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONDUCT.html">
   Code of Conduct
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/fMRI-introduction/week_7/nilearn_stats.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/lukassnoek/NI-edu"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/lukassnoek/NI-edu/issues/new?title=Issue%20on%20page%20%2FfMRI-introduction/week_7/nilearn_stats.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/lukassnoek/NI-edu/edit/master/NI-edu/fMRI-introduction/week_7/nilearn_stats.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/lukassnoek/NI-edu/master?urlpath=tree/NI-edu/fMRI-introduction/week_7/nilearn_stats.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        <a class="jupyterhub-button" href="https://neuroimaging.lukas-snoek.com/hub/user-redirect/git-pull?repo=https://github.com/lukassnoek/NI-edu&urlpath=tree/NI-edu/NI-edu/fMRI-introduction/week_7/nilearn_stats.ipynb&branch=master"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="../../_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-is-nilearn">
   What is Nilearn?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#data-formats">
   Data formats
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nifti-images">
     Nifti images
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tsv-files-or-a-short-introduction-to-pandas">
     TSV files (or: a short introduction to Pandas)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#creating-design-matrices">
   Creating design matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-an-hrf-model">
     Defining an HRF model
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creating-hrf-convolved-regressors">
     Creating HRF-convolved regressors
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-the-high-level-make-first-level-design-matrix-function">
     Using the high-level
     <code class="docutils literal notranslate">
      <span class="pre">
       make_first_level_design_matrix
      </span>
     </code>
     function
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#first-level-models">
   First-level models
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#constructing-and-fitting-first-level-models">
     Constructing and fitting first-level models
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-contrasts-from-first-level-models">
     Computing contrasts from first-level models
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#second-level-models">
   Second-level models
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#concluding-remarks">
   Concluding remarks
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="statistics-with-nilearn">
<h1>Statistics with Nilearn<a class="headerlink" href="#statistics-with-nilearn" title="Permalink to this headline">¶</a></h1>
<p>This notebook is about the GLM/statistics-related functionality of the <a class="reference external" href="https://nilearn.github.io/">nilearn</a> Python package for statistical analysis of fMRI data. While it is still in development, it promises to become a full-fledged Python-based alternative to existing (f)MRI analysis software packages such as FSL, SPM, and AFNI.</p>
<p>In this notebook, we’ll showcase the most important features of the statistics-related functionality of the package in a step-by-step fashion. Notably, this notebook contains several exercises (which we call “ToDos”), which are meant to make this tutorial more interactive! Also, this tutorial is merely an introduction to (parts of) the Nilearn package. We strongly recommend checking out the excellent <a class="reference external" href="https://nilearn.github.io/user_guide.html">user guide</a> and <a class="reference external" href="https://nilearn.github.io/auto_examples/index.html">example gallery</a> on the Nilearn website if you want to delve deeper into the package’s (more advanced) features.</p>
<p>While not strictly necessary, you’ll get the most out of this tutorial if you are familiar with the Nilearn package. To familiarize yourself, you could go through our <a class="reference external" href="https://github.com/lukassnoek/nilearn-tutorial">Nilearn tutorial</a>. (For students doing either of the <em>Neuroimaging</em> courses at the University of Amsterdam: the <code class="docutils literal notranslate"><span class="pre">nilearn.ipynb</span></code> notebook should be in your home-folder already.) Also, this notebook contains a very short introduction to the <a class="reference external" href="https://pandas.pydata.org/">pandas</a> package, but this can be skipped by those who are already familiar with it.</p>
<p><strong>Contents</strong></p>
<ol class="simple">
<li><p>What is Nilearn?</p></li>
<li><p>Data formats</p></li>
<li><p>Creating design matrices</p></li>
<li><p>First-level models</p></li>
<li><p>Second-level models</p></li>
</ol>
<p><strong>Estimated time needed to complete</strong>: 1-3 hours (depending on your experience with Python)<br>
<strong>Credits</strong>: if you end up using <code class="docutils literal notranslate"><span class="pre">nilearn</span></code> in your work, please cite the corresponding <a class="reference external" href="https://www.frontiersin.org/articles/10.3389/fninf.2014.00014/full">article</a>.<br></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Install packages if necessary</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">nilearn</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="o">!</span>pip install nilearn

<span class="c1"># We need to limit the amount of threads numpy can use, otherwise</span>
<span class="c1"># it tends to hog all the CPUs available when using Nilearn</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;MKL_NUM_THREADS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;OPENBLAS_NUM_THREADS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-danger'>
    <b>Warning</b>: This notebook uses a lot of RAM (up to 8GB at some point), so make sure your computer/server can handle this!
</div><div class="section" id="what-is-nilearn">
<h2>What is Nilearn?<a class="headerlink" href="#what-is-nilearn" title="Permalink to this headline">¶</a></h2>
<p>Nilearn is one of the packages in the growing “nipy” ecosystem of Python packages for neuroimaging analysis (see also MNE, nilearn, nipype, nibabel, and dipy). One of the (recently added) features of the package is the ability to run statistical (mostly univariate) analyses of fMRI data. (This functionality was previously implemented in the “Nistats” package, which has been merged into Nilearn recently.) Importantly, Nilearn does not contain functionality to preprocess your (f)MRI data and assumes that your data has been preprocessed by another software package. Personally, we think it works very well in combination with preprocessed data using the <a class="reference external" href="https://fmriprep.readthedocs.io/">Fmriprep</a> package.</p>
<div class='alert alert-danger'>
    <b>Note</b>: Nilearn is a relatively new package and its API might change! If code in this notebook gives errors because it uses an old version of Nilearn, let us know. 
</div><p>Most statistical functionality in Nilearn is stored in the <code class="docutils literal notranslate"><span class="pre">glm</span></code> module (i.e., <code class="docutils literal notranslate"><span class="pre">nilearn.glm</span></code>), which itself contains submodules for first-level analyses (in <code class="docutils literal notranslate"><span class="pre">nilearn.glm.first_level</span></code>) and higher-level analyses (in <code class="docutils literal notranslate"><span class="pre">nilearn.glm.second_level</span></code>).</p>
</div>
<div class="section" id="data-formats">
<h2>Data formats<a class="headerlink" href="#data-formats" title="Permalink to this headline">¶</a></h2>
<p>The two most important data formats that are used in the Nilearn package are nifti images and comma- or tab-separated values (CSV, TSV) text files.</p>
<div class="section" id="nifti-images">
<h3>Nifti images<a class="headerlink" href="#nifti-images" title="Permalink to this headline">¶</a></h3>
<p>Like most packages in the <em>nipy</em> ecosystem, Nilearn assumes that your MRI data is stored in nifti images, and as such, many functions in Nilearn involving nifti images accept either strings pointing towards the path of a nifti file (or a list with multiple paths) or a <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object from the <code class="docutils literal notranslate"><span class="pre">nibabel</span></code> package. Together, these two types of inputs (filenames pointing to nifti files and <code class="docutils literal notranslate"><span class="pre">Nifti1Images</span></code>) are often referred to a “niimgs” (or “niimg-like”) by Nilearn — a term you’ll see a lot in the documentation.</p>
<p>Let’s actually download some data! In this tutorial, we use data from the <a class="reference external" href="https://www.narps.info/">NARPS</a> project (<a class="reference external" href="https://www.nature.com/articles/s41597-019-0113-7">Botvinik-Nezer et al., 2019a</a>; <a class="reference external" href="https://www.biorxiv.org/content/10.1101/843193v1">Botvinik-Nezer et al., 2019b</a>). This public dataset was analyzed by 70 different research groups to showcase the variety in analysis approaches and the way this affects the subsequent results. In the study, a “mixed gambles” experiment was used to investigate how potential monetary gains and losses are related to brain activity (which was based on the experiment by <a class="reference external" href="https://science.sciencemag.org/content/315/5811/515">Tom et al., 2007</a>).</p>
<p>Each trial, participants were presented simulatenously with a potential monetary “gain” (e.g., <b><font color='green'>+12</font></b>) and a potential monetary “loss” (e.g., <b><font color='red'>-6</font></b>. For each trial, participants had to choose whether to accept this gamble (either “strongly accept”, “weakly accept”, “weakly reject”, or “strongly reject”), knowing that at the end of the experiment, one trial (“gamble”) would be picked randomly and (if chosen) would be “run” with a 50/50 chance of losing the original “loss” amount and winning the original “gain” amount. As such, the following information was recorded per trial: potential gain amount, potential loss amount, reaction time (of participant’s response), and the participant’s choice/decision.</p>
<div class='alert alert-warning'>
    <b>ToDo</b>: Go to the <a href='https://www.narps.info/analysis.html'>NARPS website</a> and read through the "data and analysis" section to get an idea of the experiment and scanning procedure.
</div><p>The dataset is publicly available from <a class="reference external" href="http://openneuro.org/">Openneuro.org</a>, which also includes preprocessed data (using <a class="reference external" href="https://fmriprep.readthedocs.io/">Fmriprep</a>) — perfect for our purposes! The cell below will download the data, which may take a while because it’s 2.4 GB in size.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, we need the `awscli` package to download the data; install if necessary</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">awscli</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Installing awscli package ...&quot;</span><span class="p">)</span>
    <span class="o">!</span>pip install awscli

<span class="c1"># We&#39;ll save the data in your home folder</span>
<span class="c1"># Note: the os.path.join function concatenates paths using the delimiter specific</span>
<span class="c1"># to your operating system (\ for windows, / for Mac/Linux)</span>
<span class="kn">import</span> <span class="nn">os</span> 
<span class="n">save_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s1">&#39;NARPS&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">save_dir</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data will be saved in </span><span class="si">%s</span><span class="s2"> ...&quot;</span> <span class="o">%</span> <span class="n">save_dir</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Go get some coffee. This may take a while.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Using the CLI interface of the `awscli` Python package, we&#39;ll download the data</span>
    <span class="c1"># Note that we only download the preprocessed data from a single run from a single subject</span>
    <span class="c1"># This may take about 10-60 minutes or so (depending on your download speed)</span>
    <span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds001734 <span class="o">{</span>save_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;*fmriprep/sub-00[1,3]/func/*run-01*space-MNI*.nii.gz&quot;</span>
    <span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds001734 <span class="o">{</span>save_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;*fmriprep/sub-00[1,3]/func/*run-01*.tsv&quot;</span>
    <span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds001734 <span class="o">{</span>save_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;*sub-00[1,3]/func/*run-01*events.tsv&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done!&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data is already downloaded!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, let’s check out the directory in which we saved the downloaded data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">list_files</span><span class="p">(</span><span class="n">startpath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Simple function to show directory tree. </span>
<span class="sd">    From: https://stackoverflow.com/questions/9727673/list-directory-tree-structure-in-python. &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">startpath</span><span class="p">):</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">startpath</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">/&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">root</span><span class="p">)))</span>
        <span class="n">subindent</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subindent</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
            
<span class="n">list_files</span><span class="p">(</span><span class="n">save_dir</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, this directory contains both subdirectories with “unprocessed” data (in <code class="docutils literal notranslate"><span class="pre">sub-001/func</span></code>) and preprocessed data (in <code class="docutils literal notranslate"><span class="pre">derivatives/fmriprep/sub-001/func</span></code>). Note that we excluded the raw (unprocessed) MRI data to save disk space (and time).</p>
<p>Now, let’s check out an fMRI file. We’ll load the preprocessed <code class="docutils literal notranslate"><span class="pre">sub-001_task-MGT_run-01_bold_space-MNI152NLin2009cAsym_preproc.nii.gz</span></code> (which has been registered and resampled to standard MNI152 space already) using <code class="docutils literal notranslate"><span class="pre">nibabel</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="n">fmri_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;fmriprep&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001_task-MGT_run-01_bold_space-MNI152NLin2009cAsym_preproc.nii.gz&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fmri_path</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data does not seem to be downloaded (correctly).</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;Try removing the data and re-downloading it!&quot;</span><span class="p">)</span>
<span class="n">fmri</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fmri_path</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Do you remember how to inspect <tt>Nifti1Images</tt> from <tt>nibabel</tt>? Try to figure out this scan's TR and how many volumes (timepoints) this file has. Store the TR in a variable named <tt>tr_todo</tt> and the number of volumes in <tt>nvol_todo</tt>. 
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the ToDo above. &#39;&#39;&#39;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">tr_todo</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">nvol_todo</span> <span class="o">==</span> <span class="mi">453</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="tsv-files-or-a-short-introduction-to-pandas">
<h3>TSV files (or: a short introduction to Pandas)<a class="headerlink" href="#tsv-files-or-a-short-introduction-to-pandas" title="Permalink to this headline">¶</a></h3>
<p><em>(If you’re familiar with the Pandas package, you may skip this section.)</em></p>
<p>The other type of file you’ll probably encounter a lot when working with Nilearn is a TSV (tab-separated values) file. This plain-text file is like a spreadsheet with different “observations” in rows and different “attributes” in columns. For example, according to the Brain Imaging Data Structure (<a class="reference external" href="https://bids.neuroimaging.io/">BIDS</a>), information about your experiment (like trial onsets, durations, conditions, etc.) should be stored in a TSV file ending in <code class="docutils literal notranslate"><span class="pre">_events.tsv</span></code>.</p>
<p>As expected, the data we downloaded also contains such an event-file, <code class="docutils literal notranslate"><span class="pre">sub-001_task-MGT_run-01_events.tsv</span></code>. (Note that these event-files are stored in the “unprocessed” data directory, not the “derivatives” directory).</p>
<p>These TSV files can be loaded into Python using the <a class="reference external" href="https://pandas.pydata.org/">pandas</a> package. <code class="docutils literal notranslate"><span class="pre">pandas</span></code> is usually imported as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<p>Then, TSV files (or any x-delimited files, like CSV files) can be loaded in using the <code class="docutils literal notranslate"><span class="pre">pd.read_csv</span></code> function. Let’s do that for our events-file:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001_task-MGT_run-01_events.tsv&#39;</span><span class="p">)</span>
<span class="n">events_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">events_df</span>  <span class="c1"># putting events_df at the end of a cell (instead of printing it) will show a nicely formatted table</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: What do you think the argument <tt>sep='\t'</tt> does? Try removing the argument to see what happens.
</div><p>As you can see, the <code class="docutils literal notranslate"><span class="pre">pd.read_csv</span></code> function returns a table-like object with 64 rows (corresponding to the experiment’s events/trials) and 6 columns (corresponding to different attributes of the trials, like onset, duration, etc.). The <code class="docutils literal notranslate"><span class="pre">events_df</span></code> is a custom Pandas object called a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">events_df</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Pandas <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> are similar to dataframes in the R programming language. A full introduction to Pandas is beyond the scope of this tutorial (see <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html">10 minutes to pandas</a> for a nice introduction), but we’ll highlight some useful Pandas-related functionality below.</p>
<p>One thing that is useful to know is that <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> have both row and column names. The row names are usually referred to as the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>’s <em>index</em> (these are the elements left of the “onset” column, i.e., 0, 1, 2, … 63). Row and column names can be of any type (strings, like the “onset” column, integers, like the row names in this <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, etc.).</p>
<p>To select particular rows and/or columns, you can use the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> and <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> methods, where the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> method selects based on the <em>name</em> of the row/column (like a dictionary) and the <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> method selects based on the <em>position</em>(i.e., the “number”) of the row/column (like a list).</p>
<p>The syntax of a <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">iloc</span></code> based selection is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row_name</span><span class="p">,</span> <span class="n">col_name</span><span class="p">]</span>
<span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_index</span><span class="p">,</span> <span class="n">col_index</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the square brackets (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) are different than what you expect from a <em>method</em>, but the technicalities are beyond the scope of this tutorial.</p>
<p>Anyway, to for example select the <code class="docutils literal notranslate"><span class="pre">onset</span></code> column (and all rows), we can do the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the : tells loc to select *all* the rows</span>
<span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;onset&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>And to select the first ten rows (and all columns), we can do the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Just like regular Python lists, iloc accepts slice syntax (like :10, or 5:12:2)</span>
<span class="n">events_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">10</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> In the example above, we used <tt>iloc</tt> to select the first ten rows of the <tt>DataFrame</tt>, but we could have also used <tt>loc</tt> for this purpose (try it out yourself by substituting <tt>loc</tt> for <tt>iloc</tt>). Why do you think this is the case? Is this always possible?
</div><p>Note that you can also select multiple rows and/or columns at the same time by passing a list or tuple to the <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">iloc</span></code> indexers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">events_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Let's practice a little. Select from <tt>events_df</tt> all odd rows <em>in a single statement</em> and store it in a variable named <tt>odd_rows</tt>. For a refresher on slicing in Python, see <a href="https://www.pythoncentral.io/how-to-slice-listsarrays-and-tuples-in-python/">here</a>).
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the ToDo above. &#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">assert</span><span class="p">(</span><span class="n">odd_rows</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">odd_rows</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Select the last 10 rows and the onset and duration columns <em>in a single statement</em> and store it in a variable named <tt>last10_onset_duration</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">last10_onset_duration</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">last10_onset_duration</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">])</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">last10_onset_duration</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">54</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Another useful approach for selecting subsets of observations (i.e., rows) in <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> is <em>boolean indexing</em>. For example, to create an index that selects all trials (rows) in which the participant indicated “strongly_accept” (i.e., accepting a trial’s proposed bet), we can do:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bool_idx</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;participant_response&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;strongly_accept&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bool_idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>and we can subsequently pass this index to <code class="docutils literal notranslate"><span class="pre">loc</span></code> (note that <code class="docutils literal notranslate"><span class="pre">iloc</span></code> doesn’t work with boolean indices):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strongly_accept_trials</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bool_idx</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">strongly_accept_trials</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Using boolean indexing, select all trials with a reaction time smaller than 1.5 seconds and store the result in a variable named <tt>rt_smaller_than_1p5</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">rt_smaller_than_1p5</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;RT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mf">1.2196</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Well done!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">loc</span></code> and <code class="docutils literal notranslate"><span class="pre">iloc</span></code> to create new columns. For example, let’s add a new column, <code class="docutils literal notranslate"><span class="pre">&quot;random_numbers&quot;</span></code>, with some random numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note that you can access the shape (nr of rows, nr of cols) of a DataFrame using</span>
<span class="c1"># the .shape attribute (just like numpy arrays)!</span>
<span class="n">rnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">events_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;random_numbers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rnd</span>
<span class="n">events_df</span>
</pre></div>
</div>
</div>
</div>
<p>To delete a row or column, you can use the <code class="docutils literal notranslate"><span class="pre">drop</span></code> method. Note that you should pass a particular <code class="docutils literal notranslate"><span class="pre">axis</span></code> to <code class="docutils literal notranslate"><span class="pre">drop</span></code>, either <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> (should I drop rows?) or <code class="docutils literal notranslate"><span class="pre">axis=1</span></code> (should I drop columns?):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">events_df</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;random_numbers&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">events_df</span>
</pre></div>
</div>
</div>
</div>
<p>There are many, many more things you can do with Pandas, but for now, this should suffice for our purposes.</p>
</div>
</div>
<div class="section" id="creating-design-matrices">
<h2>Creating design matrices<a class="headerlink" href="#creating-design-matrices" title="Permalink to this headline">¶</a></h2>
<p>Before we are going to fit any model on our fMRI data (<span class="math notranslate nohighlight">\(y\)</span>), we are going to focus on what we’re going to put into the model: the design matrix (<span class="math notranslate nohighlight">\(\mathbf{X}\)</span>)! Note that Nilearn offers different ways to create design matrices (and fit univariate models in general), some offer a relatively “high-level” interface (such as <code class="docutils literal notranslate"><span class="pre">first_level_model_from_bids</span></code>) while others only offer the building blocks (such as different HRF models and various types of regression models) that you can use to build the models yourself.</p>
<p>These multiple interfaces for the same functionality is especially apparent when constructing design matrices using Nilearn. In this section, we’ll start at the lowest level and work ourselves up to the more convenient (but less flexible) higher level interfaces.</p>
<p>That said, let’s go back to design matrices. What do you need to construct them? Roughly, you need the following:</p>
<ul class="simple">
<li><p>A particular HRF model</p></li>
<li><p>Information about event onset, duration, and (optionally) amplitude (weight);</p></li>
<li><p>Information about fMRI scan timing;</p></li>
</ul>
<p>Using these three components, we can construct HRF-informed regressors for our events on the time scale of our fMRI signal.</p>
<div class="section" id="defining-an-hrf-model">
<h3>Defining an HRF model<a class="headerlink" href="#defining-an-hrf-model" title="Permalink to this headline">¶</a></h3>
<p>First, let’s try to explicitly construct an HRF model using Nilearn. The <code class="docutils literal notranslate"><span class="pre">nilearn.glm.first_level.hemodynamic_models</span></code> module contains various HRF models. Let’s start with the good old canonical “Glover” HRF:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.first_level.hemodynamic_models</span> <span class="kn">import</span> <span class="n">glover_hrf</span>
</pre></div>
</div>
</div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">glover_hrf</span></code> function takes a couple of arguments, most importantly: <code class="docutils literal notranslate"><span class="pre">tr</span></code> (temporal resolution of your fMRI scan in seconds) and <code class="docutils literal notranslate"><span class="pre">oversampling</span></code> (how much to temporally upsample the HRF relative to your <code class="docutils literal notranslate"><span class="pre">tr</span></code>; you can usually safely ignore the other two arguments, <code class="docutils literal notranslate"><span class="pre">time_length</span></code> and <code class="docutils literal notranslate"><span class="pre">onset</span></code>).</p>
<p>Suppose that we want to define our HRF on the scale of 0.01 seconds, and knowing that our fMRI scan has a TR of 1, we can do the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">canon_hrf</span> <span class="o">=</span> <span class="n">glover_hrf</span><span class="p">(</span><span class="n">tr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And let’s plot it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># Define timepoints corresponding to HRF</span>
<span class="n">t_hrf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_hrf</span><span class="p">,</span> <span class="n">canon_hrf</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (A.U.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (seconds)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Canonical (&quot;Glover&quot;&quot;) HRF&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Sometimes, people like to use a <em>basis set</em> of functions as a model for the HRF, such as the temporal and dispersion derivatives of the canonical HRF (in addition to the canonical HRF itself). The <tt>nilearn</tt> package also includes these temporal and dispersion derivatives: <tt>glover_time_derivative</tt> and <tt>glover_dispersion_derivative</tt>. Import these functions, construct these HRF derivatives, and plot all three together in the same figure (like the one above).
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. (No test cell.) &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="creating-hrf-convolved-regressors">
<h3>Creating HRF-convolved regressors<a class="headerlink" href="#creating-hrf-convolved-regressors" title="Permalink to this headline">¶</a></h3>
<p>Now, to create actual regressors, we need our event onsets and durations. At the lowest level interface, we only need the onsets, durations, and amplitudes (weights) of our events of a particular condition. For now, let’s focus on the “strongly_accept” condition (note that you can define a “condition” using whatever feature from the experiment, such as the gains or losses, or even reaction time). There is no reason to focus only on these type of trials other than for the sake of the example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">idx</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;participant_response&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;strongly_accept&#39;</span>
<span class="n">sa_events</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">]]</span>
<span class="n">sa_events</span><span class="p">[</span><span class="s1">&#39;amplitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set the same amplitude for each event</span>
<span class="n">sa_events</span>
</pre></div>
</div>
</div>
</div>
<p>The next step is to create an event regressor (basically arrays with zeros, containing ones at the onset of events) and convolving this array with our HRF model. We can do this easily using the <code class="docutils literal notranslate"><span class="pre">compute_regressor</span></code> function from the <code class="docutils literal notranslate"><span class="pre">nilearn.glm.first_level.hemodynamic_models</span></code> module:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.first_level.hemodynamic_models</span> <span class="kn">import</span> <span class="n">compute_regressor</span>
</pre></div>
</div>
</div>
</div>
<p>The most important arguments of this function are the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">exp_condition</span></code>: an array of shape <span class="math notranslate nohighlight">\(3\)</span> (onset, duration, amplitude) <span class="math notranslate nohighlight">\(\times N\)</span> (events for a particular condition)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hrf_model</span></code>: a <strong>string</strong> indicating the HRF model (‘spm’, ‘spm + derivative’, ‘spm + derivative + dispersion’,
‘glover’, ‘glover + derivative’, ‘glover + derivative + dispersion’, ‘fir’)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frame_times</span></code>: an array of shape <span class="math notranslate nohighlight">\(T\)</span> (timepoints of fMRI series) containing the acquisition time of each fMRI volume</p></li>
</ul>
<p>First, let’s define <code class="docutils literal notranslate"><span class="pre">exp_condition</span></code> by pulling out the array from <code class="docutils literal notranslate"><span class="pre">sa_events</span></code> (using the <code class="docutils literal notranslate"><span class="pre">.values</span></code> attribute of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>) and transposing it (otherwise it would be of the wrong shape, i.e., <span class="math notranslate nohighlight">\(N \times 3\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp_condition</span> <span class="o">=</span> <span class="n">sa_events</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="n">exp_condition</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s for simplicity just use a canonical (Glover) HRF:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hrf_model</span> <span class="o">=</span> <span class="s1">&#39;glover&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>And we’ll define the frame times relative to the middle slice (i.e., assuming for simplicity that each slice was recorded at TR / 2):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_vols</span> <span class="o">=</span> <span class="mi">453</span>
<span class="n">tr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">tr</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_vols</span> <span class="o">*</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">tr</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_vols</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, now we have everything to compute the regressor using <code class="docutils literal notranslate"><span class="pre">compute_regressor</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The function compute_regressor returns two things:</span>
<span class="c1"># the convolved regressor(s) and a (default) name(s)</span>
<span class="n">reg</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">compute_regressor</span><span class="p">(</span>
    <span class="n">exp_condition</span><span class="o">=</span><span class="n">exp_condition</span><span class="p">,</span>
    <span class="n">hrf_model</span><span class="o">=</span><span class="n">hrf_model</span><span class="p">,</span>
    <span class="n">frame_times</span><span class="o">=</span><span class="n">frame_times</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (A.U.)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (seconds)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;HRF-convolved regressor&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>One of the analyses of NARPS project was to investigate the parametric effect of <em>gains</em> (i.e., the amount that could be gained for this trial), effectively asking: which voxels show activity that linearly relates to gains? For this analysis, you’d need both a simple “gamble-vs-baseline” regressor (like we computed before, but then for all trials instead of just the “strongly_accept” ones) and a “parametric modulation” regressor. This parametric modulation regressor uses the same onsets and durations as the “trial-vs-baseline” regressor, but <em>also</em> includes varying modulation values that indicate how much the effect of the gamble is modulated. Importantly, these modulation values should be mean-centered (or “demeaned”), i.e., its mean should be zero. You can mean-center any variable <span class="math notranslate nohighlight">\(x\)</span> by subtracting the mean (<span class="math notranslate nohighlight">\(\bar{x}\)</span>) from all values:</p>
<p>\begin{align}
x_{\mathrm{demeaned}} = x - \bar{x}
\end{align}</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (optional): Create a parametric regressor that is modulated by the "gain" values. You can do this by making sure that the third row in the array that is passed as the <tt>exp_condition</tt> argument of <tt>compute_regressor</tt> reflects the mean-centered gain values. Store the resulting regressor in a variable named <tt>parametric_gain_reg</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">parametric_gain_reg</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mf">0.0095463</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="using-the-high-level-make-first-level-design-matrix-function">
<h3>Using the high-level <code class="docutils literal notranslate"><span class="pre">make_first_level_design_matrix</span></code> function<a class="headerlink" href="#using-the-high-level-make-first-level-design-matrix-function" title="Permalink to this headline">¶</a></h3>
<p>While the HRF-related functions and <code class="docutils literal notranslate"><span class="pre">compute_regressor</span></code> already take care of a lot of stuff for us, you might still think that constructing a complete design matrix this way is quite cumbersome. Fortunately, Nilearn has a more high-level function for constructing complete design matrices easily called <code class="docutils literal notranslate"><span class="pre">make_first_level_design_matrix</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.first_level.design_matrix</span> <span class="kn">import</span> <span class="n">make_first_level_design_matrix</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-success'>
    <b>Tip</b>: in Jupyter notebooks, you can view any (Python) function's documentation, or "docstring", by running the function (without brackets) followed by a question mark, e.g., <tt>make_first_level_design_matrix?</tt>. Try this below. You can remove the pop-up by clicking the cross-symbol in the upper right-corner.
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>make_first_level_design_matrix<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, this function needs (amongst other things) a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> (events) containing the following columns: “onset”, “duration”, “trial_type”, and (optionally) “modulation”. Then, the function will basically apply the <code class="docutils literal notranslate"><span class="pre">compute_regressor</span></code> function across the different trial types as defined in the “trial_type” column.</p>
<p>For now, let’s assume that we’d want to create a design matrix with a different (un-modulated) regressor for each of the participant responses (“weakly_accept”, “strongly_accept”, “weakly_reject”, and “strongly_reject”). Below, we’ll create the appropriate <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> for this purpose:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, extract relevant columns</span>
<span class="n">pr_events</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">,</span> <span class="s1">&#39;participant_response&#39;</span><span class="p">]]</span>

<span class="c1"># Then, rename the participant_response column to trial_type</span>
<span class="c1"># bonus: why do you think we have to specify axis=1 here?</span>
<span class="n">pr_events</span> <span class="o">=</span> <span class="n">pr_events</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;participant_response&#39;</span><span class="p">:</span> <span class="s1">&#39;trial_type&#39;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Lastly, create a &quot;modulation&quot; column with only ones (indicating no modulation)</span>
<span class="n">pr_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;modulation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># this automatically fills all rows with 1</span>
<span class="n">pr_events</span>
</pre></div>
</div>
</div>
</div>
<p>Now, the different conditions in our design are defined by the unique values in our <code class="docutils literal notranslate"><span class="pre">trial_type</span></code> column:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">pr_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;trial_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>Ah darn, we also have ‘NoResp’ trials!</p>
<div class='alert alert-warning'>
    <b>ToDo</b> Remove all 'NoResp' trials (i.e., rows) and store the new (filtered) <tt>DataFrame</tt> in a variable named <tt>pr_events_filt</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="k">assert</span><span class="p">(</span><span class="s1">&#39;NoResp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pr_events_filt</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;trial_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> Now you're ready to use <tt>make_first_level_design_matrix</tt>! Use the appropriate arguments (at least <tt>frame_times</tt>, <tt>events</tt>, and <tt>hrf_model</tt>) and make sure to use <tt>drift_model=None</tt>.
   This will prevent Nilearn from automatically adding a set of regressors to the design matrix which function as a high-pass filter (we'll take a look at this later). Store the output of the function in a new variable called <tt>dm</tt>, which should be a new pandas <tt>DataFrame</tt> of shape T (number of timepoints) x P (number of regressors, i.e., number of conditions + intercept). You can ignore the <tt>UserWarning</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the ToDo above. &#39;&#39;&#39;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">453</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
    <span class="p">[</span><span class="s1">&#39;strongly_accept&#39;</span><span class="p">,</span> <span class="s1">&#39;strongly_reject&#39;</span><span class="p">,</span> <span class="s1">&#39;weakly_accept&#39;</span><span class="p">,</span> <span class="s1">&#39;weakly_reject&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">]</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, almost done with this section. One last thing we want to show you is the <code class="docutils literal notranslate"><span class="pre">plot_design_matrix</span></code> function, which you can use to, well, plot the design matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.plotting</span> <span class="kn">import</span> <span class="n">plot_design_matrix</span>
<span class="n">dm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;dm_todo.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">plot_design_matrix</span><span class="p">(</span><span class="n">dm</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>This plot shows you a “color-coded” version of your design matrix, with time on the y-axis and the different predictors on the x-axis. Note that the brighter the color (i.e., more yellow), the higher that regressor’s value at that timepoint.</p>
<div class='alert alert-warning'>
    <b>ToDo</b> Run <tt>make_first_level_design_matrix</tt> again, but add the following arguments: <tt>drift_model='cosine'</tt> and <tt>high_pass=0.01</tt> (i.e., in Hertz, corresponding to a cutoff of 100 seconds), which will add a set of cosine regressors to the design matrix, which function as a high-pass filter for our fMRI data. Store the design matrix in a new variable named <tt>dm_with_hp</tt>. Then, plot the design matrix again to see how it looks like!
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">dm_with_hp</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">453</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
<span class="k">assert</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;drift_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">dm_with_hp</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="first-level-models">
<h2>First-level models<a class="headerlink" href="#first-level-models" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will talk about fitting first-level models and computing contrasts from their estimated parameters.</p>
<div class="section" id="constructing-and-fitting-first-level-models">
<h3>Constructing and fitting first-level models<a class="headerlink" href="#constructing-and-fitting-first-level-models" title="Permalink to this headline">¶</a></h3>
<p>At last, we can start fitting first-level GLM models! Like with constructing design matrices, there are different ways to go about defining and fitting first-level models in Nilearn:</p>
<ul class="simple">
<li><p>Using the low-level <code class="docutils literal notranslate"><span class="pre">run_glm</span></code> function;</p></li>
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> class;</p></li>
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">first_level_models_from_bids</span></code> function</p></li>
</ul>
<p>For most purposes, we recommend using the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> interface, which strikes a nice balance between flexibility (unlike the very high-level <code class="docutils literal notranslate"><span class="pre">first_level_models_from_bids</span></code> function) and ease-of-use (unlike the very low-level <code class="docutils literal notranslate"><span class="pre">run_glm</span></code> function).</p>
<p>Let’s start by importing the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> class (you may ignore the FutureWarning):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># You may ignore the DeprecationWarning</span>
<span class="kn">from</span> <span class="nn">nilearn.glm.first_level</span> <span class="kn">import</span> <span class="n">FirstLevelModel</span>
</pre></div>
</div>
</div>
</div>
<p>Note that, unlike the previous functionality from Nilearn that we discussed, <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> is not a <em>function</em>, but a custom <em>class</em> (often called a <em>type</em> in Python):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">FirstLevelModel</span><span class="p">))</span>

<span class="c1"># Contrast this with for example &#39;make_first_level_design_matrix&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">make_first_level_design_matrix</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Using custom classes, you can instantiate (“create”) objects that behave as specified in the class. Before we go on, let’s digress a little and discuss briefly how custom classes and object work.</p>
<p>One way to think about classes and objects is to see classes as <em>building blueprints</em> and the objects constructed from them as the <em>actual buildings</em>. For example, neuroimaging software in Python often work with MRI data stored in objects from the <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> class (from the <code class="docutils literal notranslate"><span class="pre">nibabel</span></code> package). An object is usually <em>constructed</em> from a class as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">some_object</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="n">optional_arg1</span><span class="p">,</span> <span class="n">optional_arg2</span><span class="p">,</span> <span class="n">optional_arg3</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, to construct a <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object, we need to pass it both data (as a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array) and an affine (also as a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Very small hypothetical brain image of 10x10x10</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Here, we construct an object (nifti_obj) from a class (nib.Nifti1Image)</span>
<span class="n">nifti_obj</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nifti_obj</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The class (“blueprint”) contains instructions about the “properties” of the object (“building”) and the “functionality” of the object. The “properties” of an object are, technically, called <em>attributes</em> and can be accessed as: <code class="docutils literal notranslate"><span class="pre">some_object.attribute_name</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> objects have an attribute named <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">nifti_obj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The “functionality” of objects are, technically, called <em>methods</em>. You can see methods as functions that are bound to a particular object. For example, <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> objects hava a method called <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code>, which extract the actual brain data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">nifti_obj</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
<span class="c1"># &#39;data&#39; is the underlying numpy array!</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Note that you should call methods in the same way as functions (i.e., using round brackets, (), which may or may not contain arguments). Like functions, method calls may (or may not) return one or more things.</p>
<div class='alert alert-success'>
    <b>Tip</b>: in Jupyter notebooks (and many other code editors), you can inspect an object's attributes and methods by typing the object's variable name followed by a dot and pressing <tt>tab</tt>, i.e., <tt>your_object.+TAB</tt>. Try it out below with the <tt>nifti_obj</tt> variable to inspect the different attributes/methods from the <tt>Nifti1Image</tt> class.
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Try out the tip here</span>
</pre></div>
</div>
</div>
</div>
<p>This topic of (custom) classes and objects is actually very important in Python. Technically, Python is an “object-oriented” programming language in which <em>everything is an object (from a particular class)</em>! But an in-depth explanation of object-oriented programming is beyond the scope of this tutorial. For now, knowing the basics about (custom) classes and objects suffices for our purposes.</p>
<p>Alright, back to the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> class.</p>
<div class='alert alert-warning'>
    <b>ToDo</b>: Check out the arguments need for the initialization of a <tt>FirstLevelModel</tt> object below.
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>FirstLevelModel<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, initializing a <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> object takes a lot of arguments (<code class="docutils literal notranslate"><span class="pre">t_r</span></code>, <code class="docutils literal notranslate"><span class="pre">slice_time_ref</span></code>, <code class="docutils literal notranslate"><span class="pre">hrf_model</span></code>, <code class="docutils literal notranslate"><span class="pre">drift_model</span></code>, etc.). Fortunately, many arguments have sensible defaults. In what follows, we’ll go through the most important arguments step by step, after which we’ll (finally!) construct a <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> object.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">t_r</span></code> argument refers to the TR (temporal resolution, in seconds) of your fMRI scan.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t_r</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">slice_time_ref</span></code> argument refers to which slice you want resample your design matrix (this is used internally to define the <code class="docutils literal notranslate"><span class="pre">frame_times</span></code>), which should be between 0 (first slice) and 1 (last slice). For example, if you slice-time corrected your fMRI data to the first slice, you should set <code class="docutils literal notranslate"><span class="pre">slice_time_ref</span></code> to 0 (middle slice → 0.5, last slice → 1, etc.). If you did not apply any slice-time correction (as is the case for the NARPS data), we recommend setting it to 0.5. (Can you think of a reason why this is a sensible choice for non-slice-time-corrected data?)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">slice_time_ref</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
</div>
</div>
<p>While you can construct your design matrix using Nilearn functionality directly, you can actually also leave it up to the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> to do this for you! That’s why you might have recognized some parameters that you’ve seen in functions from the previous section (such as <code class="docutils literal notranslate"><span class="pre">hrf_model</span></code>, <code class="docutils literal notranslate"><span class="pre">drift_model</span></code>, and <code class="docutils literal notranslate"><span class="pre">high_pass</span></code>). For now, we’ll let the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> take care of constructing a design for us, so we’ll define these parameters here:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hrf_model</span> <span class="o">=</span> <span class="s1">&#39;glover&#39;</span>
<span class="n">drift_model</span> <span class="o">=</span> <span class="s1">&#39;cosine&#39;</span>
<span class="n">high_pass</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># cutoff: 0.01 Hz (i.e., 100 seconds)</span>
</pre></div>
</div>
</div>
</div>
<p>The next important parameter is <code class="docutils literal notranslate"><span class="pre">mask_img</span></code> (note that we’re skipping some parameters, as they represent some more advanced functionality/analyses). This (optional!) parameter refers to a nifti image (a path to a nifti file or a <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object) with binary (0, 1) data indicting which voxels should be included (1) and which ones should be “masked” (0). Fortunately, Fmriprep also returns a brain-mask:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mask_img</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;fmriprep&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sub-001_task-MGT_run-01_bold_space-MNI152NLin2009cAsym_brainmask.nii.gz&#39;</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mask_img</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that including a brain-mask may substantially speed up your analysis (as it reduces the number of voxels that will be analyzed).</p>
<p>We can also spatially smooth our fMRI data by setting the <code class="docutils literal notranslate"><span class="pre">smoothing_fwhm</span></code> parameter (in millimeters):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">smoothing_fwhm</span> <span class="o">=</span> <span class="mf">3.5</span>
</pre></div>
</div>
</div>
</div>
<p>Then, the <code class="docutils literal notranslate"><span class="pre">standardize</span></code> and <code class="docutils literal notranslate"><span class="pre">signal_scaling</span></code> parameters refer to the method that will be used to mean-center the data. In this example, we’ll leave it to the default values (<code class="docutils literal notranslate"><span class="pre">standardize=False</span></code> and <code class="docutils literal notranslate"><span class="pre">signal_scaling=0</span></code>), which will only mean-center the data in the time domain (i.e., substract the mean across time from each voxel).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> parameter refers to the particular noise model of the GLM. Do we assume independent and identically distributed (IID) noise (<code class="docutils literal notranslate"><span class="pre">noise_model='ols'</span></code>) or do we assume that our noise is temporally autocorrelated (<code class="docutils literal notranslate"><span class="pre">noise_model='ar1'</span></code>)? For almost all fMRI data, we should assume that the noise is at least somewhat autocorrelated, so we’ll set <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> to <code class="docutils literal notranslate"><span class="pre">'ar1'</span></code>. (Note that <code class="docutils literal notranslate"><span class="pre">'ar1'</span></code> is a bit slower than <code class="docutils literal notranslate"><span class="pre">'ols'</span></code>, so you may consider using <code class="docutils literal notranslate"><span class="pre">'ols'</span></code> when for example testing your code.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise_model</span> <span class="o">=</span> <span class="s1">&#39;ar1&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>Then, the <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> parameter determines how many CPU cores the GLM analysis will use. For now, one core should suffice:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<p>Lastly, you may want to set the <code class="docutils literal notranslate"><span class="pre">minimize_memory</span></code> argument to <code class="docutils literal notranslate"><span class="pre">False</span></code>. While doing this will increase the memory (RAM) necessary for the GLM analysis, it allows use to retrieve more outputs from the GLM after fitting (such as model fit, <span class="math notranslate nohighlight">\(R^2\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">minimize_memory</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>Now we’re <em>finally</em> ready to constuct our <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> object!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flm</span> <span class="o">=</span> <span class="n">FirstLevelModel</span><span class="p">(</span>
    <span class="n">t_r</span><span class="o">=</span><span class="n">t_r</span><span class="p">,</span>
    <span class="n">slice_time_ref</span><span class="o">=</span><span class="n">slice_time_ref</span><span class="p">,</span>
    <span class="n">hrf_model</span><span class="o">=</span><span class="n">hrf_model</span><span class="p">,</span>
    <span class="n">drift_model</span><span class="o">=</span><span class="n">drift_model</span><span class="p">,</span>
    <span class="n">high_pass</span><span class="o">=</span><span class="n">high_pass</span><span class="p">,</span>
    <span class="n">mask_img</span><span class="o">=</span><span class="n">mask_img</span><span class="p">,</span>
    <span class="n">smoothing_fwhm</span><span class="o">=</span><span class="n">smoothing_fwhm</span><span class="p">,</span>
    <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
    <span class="n">minimize_memory</span><span class="o">=</span><span class="n">minimize_memory</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># this will print out some useful info later</span>
<span class="p">)</span>

<span class="sd">&quot;&quot;&quot; Note that, here, we&#39;ve defined all arguments beforehand,</span>
<span class="sd">but this is not necessary! We could have done something like:</span>
<span class="sd">flm = FirstLevelModel(</span>
<span class="sd">    t_r=1,</span>
<span class="sd">    slice_time_ref=0.5,</span>
<span class="sd">    hrf_model=&#39;glover&#39;,</span>
<span class="sd">    drift_model=&#39;cosine&#39;,</span>
<span class="sd">    high_pass=0.01,</span>
<span class="sd">    mask_img=os.path.join(etc., etc.),</span>
<span class="sd">    smoothing_fwhm=3.5,</span>
<span class="sd">    noise_model=&#39;ar1&#39;,</span>
<span class="sd">    n_jobs=1,</span>
<span class="sd">    minimize_memory=False,</span>
<span class="sd">    verbose=True</span>
<span class="sd">)</span>
<span class="sd">&quot;&quot;&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<p>Wait, what? Did it really just take a fraction of a second to fit the first-level model? Actually, no. We only <em>constructed</em> the first-level model, but we haven’t fitted it yet! To do so, we can use the, guess what, <code class="docutils literal notranslate"><span class="pre">fit</span></code> method!</p>
<div class='alert alert-warning'>
    <b>ToDo</b>: check out the arguments needed by the <tt>fit</tt> method. 
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>flm.fit<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>There are actually two ways of using the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method, depending on which parameters you use:</p>
<ol class="simple">
<li><p>define <code class="docutils literal notranslate"><span class="pre">events</span></code> (+ optionally <code class="docutils literal notranslate"><span class="pre">confounds</span></code>)</p></li>
<li><p>define <code class="docutils literal notranslate"><span class="pre">design_matrices</span></code></p></li>
</ol>
<p>Approach 1 will construct a design matrix for you (by running <code class="docutils literal notranslate"><span class="pre">make_first_level_design_matrix</span></code> on your <code class="docutils literal notranslate"><span class="pre">events</span></code> and, optionally, concatenating this with your <code class="docutils literal notranslate"><span class="pre">confounds</span></code>) while approach 2 assumes that you have constructed a design matrix yourself.</p>
<p>Note, by the way, that the parameter names are all plural (run_img<strong>s</strong>, event<strong>s</strong>, confound<strong>s</strong>, design_matrice<strong>s</strong>). This is because you can either fit a model on a <em>single</em> fMRI run or fit a model on <em>multiple</em> fMRI runs with a single <code class="docutils literal notranslate"><span class="pre">fit</span></code> call. To fit multiple runs, just pass a list instead of a single object for each parameter (e.g., <code class="docutils literal notranslate"><span class="pre">design_matrices=[dm_run1,</span> <span class="pre">dm_run2]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">design_matrices=dm</span></code>).</p>
<p>Regardless of the approach for constructing your design matrix, the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method always needs (one or more) fMRI files (for the <code class="docutils literal notranslate"><span class="pre">run_img</span></code> parameter), which can either be a <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object or string representing the path to a 4D nifti file. Furthermore, both the <code class="docutils literal notranslate"><span class="pre">events</span></code> and the <code class="docutils literal notranslate"><span class="pre">confounds</span></code> should be a Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. For our <code class="docutils literal notranslate"><span class="pre">events</span></code>, let’s use the <code class="docutils literal notranslate"><span class="pre">pr_events_filt</span></code> events, in which the participant responses represent our conditions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is also one possible solution to the ToDo earlier</span>
<span class="n">events2use</span> <span class="o">=</span> <span class="n">pr_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pr_events</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;trial_type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;NoResp&#39;</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<p>Almost always, you’d want to add some confounds to your design matrix, as confounds represent independent variables that are (often) not of interest to the researcher, but might be related to the signal (the depenent variable, <span class="math notranslate nohighlight">\(y\)</span>) anyway. Including these confounds in your design matrix will then explain some variance that might otherwise not be accounted for (which will “end up” in the model’s noise term, <span class="math notranslate nohighlight">\(\hat{\sigma}^2\)</span>), increasing the model’s power to detect effects related to the variables you’re interested in. Note that including the “right” confounds in your model is in no way trivial (and opinions differ to what confounds are the “right” ones to include)!</p>
<p>That said, fortunately, Fmriprep also computes an extensive set of timepoint-by-timepoint confounds for each fMRI run, which are conveniently stored in TSV files. (You can really see that Nilearn was designed with Fmriprep’s outputs in mind.) We’ll load these confounds below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;fmriprep&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-001_task-MGT_run-01_bold_confounds.tsv&#39;</span><span class="p">)</span>
<span class="n">confounds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">conf_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">confounds</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Read the Fmriprep <a href="https://fmriprep.readthedocs.io/en/stable/outputs.html">documentation</a> about the different confounds (scroll down to the "Confounds" section). Note that the confound names in the documentation are slightly different that in our <tt>DataFrame</tt> because this dataset was preprocessed using an older version of Fmriprep.
</div><p>As stated in Fmriprep’s documentation, it’s probably not a good idea to include <em>all</em> confounds in our model. Selecting a subset of confound parameter is, however, also not a trivial matter; which confounds are appropriate and explain to most variance in your data likely depends on the characteristics of your particular dataset (field strength, scan technique, the amount of motion in your data, etc.) and your intended analysis (univariate group-level GLM, functional connectivity, MVPA).</p>
<p>Here, we’ll be relatively conservative and include only the 6 motion parameters (<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Y</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code>, <code class="docutils literal notranslate"><span class="pre">RotX</span></code>, <code class="docutils literal notranslate"><span class="pre">RotY</span></code>, <code class="docutils literal notranslate"><span class="pre">RotZ</span></code>) and the non-steady-state outlier (<code class="docutils literal notranslate"><span class="pre">NonSteadyStateOutlier00</span></code>; i.e., a binary-coded regressor removing the influence of volumes at the beginning of a run that contain too much T1-contrast).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">confounds2use</span> <span class="o">=</span> <span class="n">confounds</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;RotX&#39;</span><span class="p">,</span> <span class="s1">&#39;RotY&#39;</span><span class="p">,</span> <span class="s1">&#39;RotZ&#39;</span><span class="p">,</span> <span class="s1">&#39;NonSteadyStateOutlier00&#39;</span><span class="p">]]</span>
<span class="n">confounds2use</span>
</pre></div>
</div>
</div>
</div>
<p>In fact, we can reuse the <code class="docutils literal notranslate"><span class="pre">plot_design_matrix</span></code> function to visualize this “confound design matrix”:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plot_design_matrix</span><span class="p">(</span><span class="n">confounds2use</span><span class="p">)</span>
<span class="c1"># Rescale the colors a little</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_images</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, now we can <em>finally</em> fit our model (this may take 2-5 minutes or so, depending on how fast your computer/server is; go get some coffee)!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">run_imgs</span><span class="o">=</span><span class="n">fmri</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="n">events2use</span><span class="p">,</span> <span class="n">confounds</span><span class="o">=</span><span class="n">confounds2use</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fit</span></code> function doesn’t return the results of the GLM analysis, but stores it as attributes. This includes the constructed design matrix (or matrices, when there is more than one run):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the design_matrices_ attribute is a list with, in our case, only a single</span>
<span class="c1"># element</span>
<span class="n">flm_dm</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">design_matrices_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Let&#39;s plot it again</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plot_design_matrix</span><span class="p">(</span><span class="n">flm_dm</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_images</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Another result from the GLM that we can inspect is model fit, expressed as <span class="math notranslate nohighlight">\(R^2\)</span> (only when <code class="docutils literal notranslate"><span class="pre">minimize_memory=False</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Again, it returns a list, and we&#39;ll take the first element,</span>
<span class="c1"># because we only have one run</span>
<span class="n">r2_img</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">r_square</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">r2_img</span></code> variable is a 3D <code class="docutils literal notranslate"><span class="pre">Nifti1Image</span></code> object with voxelwise <span class="math notranslate nohighlight">\(R^2\)</span> values. We can visualize this using the <code class="docutils literal notranslate"><span class="pre">plotting</span></code> module from Nilearn (e.g., using <code class="docutils literal notranslate"><span class="pre">plot_stat_map</span></code> with an arbitrary threshold of 0.2):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn</span> <span class="kn">import</span> <span class="n">plotting</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_stat_map</span><span class="p">(</span><span class="n">r2_img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>Another thing we can inspect is the residual time series from the model fit, which we can retrieve using the <code class="docutils literal notranslate"><span class="pre">residuals</span></code> attribute (you can ignore the <code class="docutils literal notranslate"><span class="pre">FutureWarning</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">resids</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">resids</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">resids</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (optional): If you want to brush up your Nilearn skills, try computing the standard deviation across time for each voxel in the <tt>resids</tt> variable. Store the result (a <tt>Nifti1Image</tt>) in a new variable called <tt>r_std</tt>. Then, plot the result using <tt>plot_stat_map</tt> using a threshold of 3. You should clearly see the brain's veins and contours (effects of movement?) in the plot! Hint: perhaps the function <tt>nilearn.image.math_img</tt> is of use here ... (but this ToDo can be implemented in various ways)
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the (optional) ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">r_std</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mf">0.34867</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s remove the residuals variable, which uses a lot of memory</span>
<span class="k">del</span> <span class="n">flm</span><span class="o">.</span><span class="n">residuals</span><span class="p">,</span> <span class="n">resids</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="computing-contrasts-from-first-level-models">
<h3>Computing contrasts from first-level models<a class="headerlink" href="#computing-contrasts-from-first-level-models" title="Permalink to this headline">¶</a></h3>
<p>The last thing we’ll discuss in this section is computing contrasts and thresholding the resulting statistical images. Computing contrasts using <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> objects is ridiculously easy. This is done using the <code class="docutils literal notranslate"><span class="pre">compute_contrast</span></code> method.</p>
<div class='alert alert-warning'>
    <b>ToDo</b>: Check out the arguments needed for the <tt>compute_contrast</tt> method. 
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>flm.compute_contrast<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">contrast_def</span></code> parameter represents the contrast you want compute and can be used in different ways. One way is to specify a contrast vector (a list or a numpy array). For example, if we’d like to evaluate the contrast “strongly_accept &gt; baseline”, we could specify the contrast vector as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">con_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flm</span><span class="o">.</span><span class="n">design_matrices_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">con_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">con_vec</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that values of the contrast vector are assumed to relate to the regressors froms the design matrix in the same order (e.g., the first value from the contrast vector corresponds to the first regressor in your design matrix, i.e., the first column).</p>
<p>Then, we can compute the contrast as following (assuming a single contrast, i.e., <code class="docutils literal notranslate"><span class="pre">stat_type='t'</span></code>, and wanting <span class="math notranslate nohighlight">\(z\)</span>-values as output, i.e., <code class="docutils literal notranslate"><span class="pre">output_type='z_score'</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">con_img</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="n">con_vec</span><span class="p">,</span> <span class="n">stat_type</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>How does that look like?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_stat_map</span><span class="p">(</span><span class="n">con_img</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The same contrast can be evaluated by using a string describing a “formula”. In the “strongly_accept &gt; baseline” contrast, this is trivial:</p>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">con_img2</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="s1">&#39;strongly_accept&#39;</span><span class="p">,</span> <span class="n">stat_type</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
<span class="c1"># check that it is literally the same; if it&#39;s not, it will give an error</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">con_img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">(),</span> <span class="n">con_img2</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>But we can also define more complicated contrasts, such as “(strongly_accept + weakly_accept) &gt; strongly_reject” (note that this is theoretically a nonsense contrast and just used for the sake of the example):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: the same contrast can be defined using the contrast vector:</span>
<span class="c1"># [1, -2, 1, 0, 0, 0, 0, ..., 0]</span>
<span class="n">contrast_def</span> <span class="o">=</span> <span class="s1">&#39;strongly_accept + weakly_accept - 2*strongly_reject&#39;</span>
<span class="n">con_img</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="n">contrast_def</span><span class="p">,</span> <span class="n">stat_type</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that <span class="math notranslate nohighlight">\(z\)</span>-values are not the only output type possible. The other options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'stat'</span></code>: either the <span class="math notranslate nohighlight">\(t\)</span>-value or <span class="math notranslate nohighlight">\(F\)</span>-value, depending on <code class="docutils literal notranslate"><span class="pre">stat_type</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'p_value'</span></code>: the <span class="math notranslate nohighlight">\(p\)</span>-value associated with the <span class="math notranslate nohighlight">\(t\)</span> of <span class="math notranslate nohighlight">\(F\)</span>-value;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'effect_size'</span></code>: the dot product of the contrast vector and the parameters (<span class="math notranslate nohighlight">\(c\hat{\beta}\)</span>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'effect_variance'</span></code>: the variance of the dot product of the contrast vector and the parameters (<span class="math notranslate nohighlight">\(\mathrm{var}[c\hat{\beta}]\)</span>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'all'</span></code>: all of the above</p></li>
</ul>
<div class='alert alert-warning'>
    <b>ToDo</b>: Using either the "formula" format or the contrast vector format, compute the $t$-values associated with the contrast "reject > accept" (regardless of strongly/weakly). Store the resulting image in a variable named <tt>reject_gt_accept</tt> (gt = greater than) and plot the image using <tt>plot_stat_map</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">reject_gt_accept</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mf">0.04879</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>So far, we plotted the resulting statistic maps without a threshold (or an arbitrary one), but in a proper analysis, you’d want to statistically threshold your image to reduce the risk of false positives. In Nilearn, this can be done using the function <code class="docutils literal notranslate"><span class="pre">threshold_stats_img</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.thresholding</span> <span class="kn">import</span> <span class="n">threshold_stats_img</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Checkout the arguments needed for the <tt>threshold_stats_img</tt> function. 
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>threshold_stats_img<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, the primary input to the <code class="docutils literal notranslate"><span class="pre">threshold_stats_img</span></code> function (i.e., <code class="docutils literal notranslate"><span class="pre">stat_img</span></code>) is assumed to consist of <span class="math notranslate nohighlight">\(z\)</span>-values.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">threshold_stats_img</span></code>, there are various ways of thresholding your statistical map. Your desired method can be indicated using the <code class="docutils literal notranslate"><span class="pre">height_control</span></code> parameter (either ‘fpr’, ‘fdr’, or ‘bonferroni’, where ‘fpr’ refers to simple p-value based thresholding without multiple comparison control). The <code class="docutils literal notranslate"><span class="pre">alpha</span></code> parameter represents the significance level that should be used. There is also an option to only include significant voxels that belong to a cluster larger than a certain amount of voxels using <code class="docutils literal notranslate"><span class="pre">cluster_threshold</span></code> (which can make plots a little more visually appealing), but realize that this is by no means a method that guarantees proper false positive control.</p>
<p>Importantly, the <code class="docutils literal notranslate"><span class="pre">threshold_stats_img</span></code> function optionally takes a mask (<code class="docutils literal notranslate"><span class="pre">mask_img</span></code>), which improves sensitivity a lot when using, for example, Bonferroni correction which depends on the number of tests. Also, note that the <code class="docutils literal notranslate"><span class="pre">threshold_stats_img</span></code> function returns two things: the thresholded map and the threshold that was actually used.</p>
<p>Anyway, let’s focus on the “strongly_reject &gt; baseline” contrast and let’s threshold it using the <code class="docutils literal notranslate"><span class="pre">'bonferroni'</span></code> method with an <code class="docutils literal notranslate"><span class="pre">alpha</span></code> of 0.01 while included the previously defined mask:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">con_img</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="s1">&#39;strongly_reject&#39;</span><span class="p">,</span> <span class="n">stat_type</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
<span class="n">con_img_thr</span><span class="p">,</span> <span class="n">used_threshold</span> <span class="o">=</span> <span class="n">threshold_stats_img</span><span class="p">(</span><span class="n">con_img</span><span class="p">,</span> <span class="n">mask_img</span><span class="o">=</span><span class="n">mask_img</span><span class="p">,</span> <span class="n">height_control</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_stat_map</span><span class="p">(</span><span class="n">con_img_thr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: threshold the same image (<tt>con_img</tt>), but this time using 'fdr' correction, an alpha of 0.01 and a cluster threshold of 100. Store the result in a variable named <tt>con_img_thr_fdr</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">con_img_thr_fdr</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mf">0.03169</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Before we go on to the next section, we want to show you one last nugget: the <code class="docutils literal notranslate"><span class="pre">make_glm_report</span></code> function (see <a class="reference external" href="https://nistats.github.io/modules/generated/nistats.reporting.make_glm_report.html#nistats.reporting.make_glm_report">documentation</a>). This function takes an <em>already fitted</em> <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> object, a contrast definition, and optionally several parameters related to computing and thresholding the statistic image(s) and returns a summary of the results (as an HTML file, which can be nicely rendered in Jupyter notebooks).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.reporting</span> <span class="kn">import</span> <span class="n">make_glm_report</span>
<span class="c1"># This may take a couple of seconds</span>
<span class="c1"># You can use your trackpad or keyboard keys to navigate the cell below</span>
<span class="c1"># (make sure you are in &quot;edit&quot; mode, i.e., the cell border should be blue;</span>
<span class="c1">#  click the cell to enter &quot;edit&quot; mode)</span>
<span class="n">make_glm_report</span><span class="p">(</span><span class="n">flm</span><span class="p">,</span> <span class="s1">&#39;strongly_accept - weakly_accept&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s clear up some memory for the last section</span>
<span class="o">%</span><span class="k">reset</span> -f
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="second-level-models">
<h2>Second-level models<a class="headerlink" href="#second-level-models" title="Permalink to this headline">¶</a></h2>
<p>The only major Nilearn functionality that we haven’t discussed is <em>second-level models</em>. Unlike first-level models, there is basically only one way to fit second-level models: using the <code class="docutils literal notranslate"><span class="pre">SecondLevelModel</span></code> class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nilearn.glm.second_level</span> <span class="kn">import</span> <span class="n">SecondLevelModel</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b>: Check out the arguments needed for initialization of a <tt>SecondLevelModel</tt> object.
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>SecondLevelModel<span class="o">?</span>
</pre></div>
</div>
</div>
</div>
<p>The second-level model class allows you to run random-effects (but not mixed-effects!) models on multiple participants. Note that it assumes that all data have been registered/resampled to a common space (e.g., MNI, such as our data). It’s interface is very similar to the <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> class (i.e., it also has a <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">compute_contrast</span></code> method). When constructing a <code class="docutils literal notranslate"><span class="pre">SecondLevelModel</span></code> object, the most important parameters are <code class="docutils literal notranslate"><span class="pre">mask_img</span></code>, an optional mask, and <code class="docutils literal notranslate"><span class="pre">smoothing_fwhm</span></code>, an optional smoothing kernel.</p>
<p>For our example, let’s do a (horribly underpowered) group-level analysis of the two subjects whose data we downloaded. First of all, we need to fit both first-level models. We’ll define a function below that does this for a single subject:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">nilearn</span> <span class="kn">import</span> <span class="n">masking</span>
<span class="kn">from</span> <span class="nn">nilearn.glm.first_level</span> <span class="kn">import</span> <span class="n">FirstLevelModel</span>

<span class="k">def</span> <span class="nf">fit_firstlevel</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">bids_dir</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="s1">&#39;MGT&#39;</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;MNI152NLin2009cAsym&#39;</span><span class="p">,</span> 
                   <span class="n">conf_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">flm_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Example function of how you could implement a complete</span>
<span class="sd">    first-level analysis for a single subject. Note that this is</span>
<span class="sd">    just one way of implementing this; there may be (much more efficient)</span>
<span class="sd">    ways to do this.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub : str</span>
<span class="sd">        Subject-identifier (e.g., &#39;sub-01&#39;)</span>
<span class="sd">    bids_dir : str</span>
<span class="sd">        Path to BIDS directory (root directory)</span>
<span class="sd">    task : str</span>
<span class="sd">        Name of task to analyse</span>
<span class="sd">    run : str</span>
<span class="sd">        Name of run to analyze</span>
<span class="sd">    space : str</span>
<span class="sd">        Name of space of the data</span>
<span class="sd">    conf_cols : list (or None)</span>
<span class="sd">        List of confound names to include; if None, only 6 motion params</span>
<span class="sd">        are included</span>
<span class="sd">    **flm_kwargs : kwargs</span>
<span class="sd">        Keyword arguments for the FirstLevelModel constructor</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flm : FirstLevelModel</span>
<span class="sd">        Fitted FirstLevelModel object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># If conf_cols is not set, let&#39;s use a &quot;standard&quot; set of</span>
    <span class="c1"># motion parameters (translation and rotation in 3 dimensions)</span>
    <span class="k">if</span> <span class="n">conf_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: in new versions of Fmriprep, these variables are named differently,</span>
        <span class="c1"># i.e., trans_x, trans_y, trans_z, rot_x, rot_y, rot_z</span>
        <span class="n">conf_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;RotX&#39;</span><span class="p">,</span> <span class="s1">&#39;RotY&#39;</span><span class="p">,</span> <span class="s1">&#39;RotZ&#39;</span><span class="p">]</span>

    <span class="c1"># We assume it&#39;s a BIDS formatted dataset with the Fmriprep outputs in</span>
    <span class="c1"># bids_dir/derivatives/fmriprep</span>
    <span class="n">bids_func_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bids_dir</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">)</span>
    <span class="n">fprep_func_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bids_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;fmriprep&#39;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">)</span>
    
    <span class="c1"># Let&#39;s find the fMRI files, given a particular space (e.g., T1w)</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fprep_func_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;*space-</span><span class="si">{</span><span class="n">space</span><span class="si">}</span><span class="s1">*_preproc*.nii.gz&#39;</span><span class="p">)))</span>

    <span class="c1"># In this loop, we&#39;ll find the events/confounds/masks associated with the funcs</span>
    <span class="n">confs</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">masks</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="c1"># First, find the associated mask</span>
        <span class="c1"># Note, this doesn&#39;t work for newer versions of Fmriprep, which uses</span>
        <span class="c1"># a slightly different naming convention for brainmasks (desc-brain_mask)</span>
        <span class="n">mask_path</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;preproc&#39;</span><span class="p">,</span> <span class="s1">&#39;brainmask&#39;</span><span class="p">)</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span>

        <span class="c1"># Find the associated confounds file</span>
        <span class="n">conf_path</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;space-</span><span class="si">{</span><span class="n">space</span><span class="si">}</span><span class="s1">_preproc.nii.gz&#39;</span><span class="p">,</span> <span class="s1">&#39;confounds.tsv&#39;</span><span class="p">)</span>
        <span class="n">conf_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">conf_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">conf_cols</span><span class="p">]</span>
        <span class="n">confs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf_df</span><span class="p">)</span>
        
        <span class="c1"># Find the associated events file</span>
        <span class="n">event_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bids_dir</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sub</span><span class="si">}</span><span class="s1">_task-</span><span class="si">{</span><span class="n">task</span><span class="si">}</span><span class="s1">_run-</span><span class="si">{</span><span class="n">run</span><span class="si">}</span><span class="s1">_events.tsv&#39;</span><span class="p">)</span>
        <span class="n">event_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">event_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># Exclude &#39;NoResp&#39; trials (not strictly necessary)</span>
        <span class="n">event_df</span> <span class="o">=</span> <span class="n">event_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;participant_response != &#39;NoResp&#39;&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set participant_response as the trial_type</span>
        <span class="n">event_df</span> <span class="o">=</span> <span class="n">event_df</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;participant_response&#39;</span><span class="p">:</span> <span class="s1">&#39;trial_type&#39;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_df</span><span class="p">)</span>

    <span class="c1"># In case there are multiple masks, create an intersection;</span>
    <span class="c1"># if not, this function does nothing</span>
    <span class="n">mask_img</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">intersect_masks</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

    <span class="c1"># Construct the first-level model!</span>
    <span class="c1"># We set the t_r to the first func we have, assuming</span>
    <span class="c1"># that the TR is the same for each run (if there are multiple runs)</span>
    <span class="n">flm</span> <span class="o">=</span> <span class="n">FirstLevelModel</span><span class="p">(</span>
        <span class="n">t_r</span><span class="o">=</span><span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;pixdim&#39;</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span>
        <span class="n">slice_time_ref</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">mask_img</span><span class="o">=</span><span class="n">mask_img</span><span class="p">,</span>
        <span class="o">**</span><span class="n">flm_kwargs</span>
    <span class="p">)</span>
    
    <span class="c1"># Finally, fit the model and return the fitted model</span>
    <span class="n">flm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">run_imgs</span><span class="o">=</span><span class="n">funcs</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="n">events</span><span class="p">,</span> <span class="n">confounds</span><span class="o">=</span><span class="n">confs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flm</span>
</pre></div>
</div>
</div>
</div>
<p>Now we can create a loop across our two subjects, estimating a first-level model for each:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bids_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">),</span> <span class="s1">&#39;NARPS&#39;</span><span class="p">)</span>
<span class="n">flms</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># This may take about 2-10 minutes, go get some coffee!</span>
<span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">((</span><span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-003&#39;</span><span class="p">)):</span>
    <span class="n">flm</span> <span class="o">=</span> <span class="n">fit_firstlevel</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">bids_dir</span><span class="p">,</span> <span class="n">drift_model</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">high_pass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">flms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flm</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, so now we have two fitted <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> objects (stored in <code class="docutils literal notranslate"><span class="pre">flms</span></code>). We will use these for our second-level model. Like <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> objects, the <code class="docutils literal notranslate"><span class="pre">SecondLevelModel</span></code> object has a <code class="docutils literal notranslate"><span class="pre">fit</span></code> method, but it is a bit more complicated, because there are different ways to specify the input for second-level models (i.e., the <code class="docutils literal notranslate"><span class="pre">second_level_input</span></code> parameter):</p>
<ol class="simple">
<li><p>a list of fitted <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> objects (easy, but limited to within-subject/run analyses only);</p></li>
<li><p>a list of first-level contrast images (i.e., with <span class="math notranslate nohighlight">\(c\hat{\beta}\)</span> values);</p></li>
<li><p>a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with information about the lower-level inputs (useful when using first-level output from other packages, such as FSL, but for Nilearn-only analyses, this is not very useful)</p></li>
</ol>
<p>The first method is quite efficient (in terms of code), because it assumes that you are only interested in an intercept-only group-level model (i.e., the average of a particular first-level contrast across participants), and you can leave out the second-level design matrix. We’ll show this below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We don&#39;t supply any mask for simplicity</span>
<span class="n">slm_method1</span> <span class="o">=</span> <span class="n">SecondLevelModel</span><span class="p">(</span><span class="n">smoothing_fwhm</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">slm_method1</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">flms</span><span class="p">)</span>  <span class="c1"># we don&#39;t have give it a design matrix!</span>
</pre></div>
</div>
</div>
</div>
<p>The second option is to give the <code class="docutils literal notranslate"><span class="pre">SecondLevelModel</span></code> a list of first-level contrast images in combination with a second-level design matrix. First, let’s compute a first-level contrast (say “strongly_accept”) for both participants:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fl_cons</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">flm</span> <span class="ow">in</span> <span class="n">flms</span><span class="p">:</span>
    <span class="n">con</span> <span class="o">=</span> <span class="n">flm</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="s1">&#39;strongly_accept&#39;</span><span class="p">,</span> <span class="n">stat_type</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;effect_size&#39;</span><span class="p">)</span>
    <span class="n">fl_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we only need to construct a second-level design matrix, which should be a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. The columns in this <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> represent the different predictors for our second-level model. For simplicity, let’s just define an intercept-only design matrix (exactly the same as we did using method 1):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specifying the index is not stringly necessary, but it looks nice</span>
<span class="n">slm_dm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;sub-001&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-003&#39;</span><span class="p">))</span>
<span class="n">slm_dm</span>
</pre></div>
</div>
</div>
</div>
<p>Using the first-level contrast images (<code class="docutils literal notranslate"><span class="pre">fl_cons</span></code>) and the second-level design matrix (<code class="docutils literal notranslate"><span class="pre">slm_dm</span></code>), we can fit our second-level model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">slm_method2</span> <span class="o">=</span> <span class="n">SecondLevelModel</span><span class="p">(</span><span class="n">smoothing_fwhm</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">slm_method2</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">fl_cons</span><span class="p">,</span> <span class="n">design_matrix</span><span class="o">=</span><span class="n">slm_dm</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Using this fitted second-level model for either method, we can also compute second-level contrasts. The way this is done is slightly different for each method. For method 1 (using fitted <code class="docutils literal notranslate"><span class="pre">FirstLevelModel</span></code> objects as inputs), the only option is to use the <code class="docutils literal notranslate"><span class="pre">first_level_contrast</span></code> parameter in the <code class="docutils literal notranslate"><span class="pre">compute_contrast</span></code> method. You can only use contrast definitions that were already present in the first-level model (because there is no second-level design matrix).</p>
<p>For example, if we’d want to compute the average (across participants) group-level contrast of “strongly_accept &gt; baseline”, we’d do:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sr_average_method1</span> <span class="o">=</span> <span class="n">slm_method1</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="n">first_level_contrast</span><span class="o">=</span><span class="s1">&#39;strongly_accept&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>For method 2 (using first-level contrast images + a second-level design matrix), we cannot use the <code class="docutils literal notranslate"><span class="pre">first_level_contrast</span></code> parameter; instead, we should use the <code class="docutils literal notranslate"><span class="pre">second_level_contrast</span></code> parameter, which applies to contrasts based on the second-level design matrix. Because we also defined an intercept-only model for method 2, the only contrast we <em>can</em> evaluate is the intercept contrast:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sr_average_method2</span> <span class="o">=</span> <span class="n">slm_method2</span><span class="o">.</span><span class="n">compute_contrast</span><span class="p">(</span><span class="n">second_level_contrast</span><span class="o">=</span><span class="s1">&#39;intercept&#39;</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s1">&#39;z_score&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the the results from both methods are virtually the same; the only difference is the way we used the <code class="docutils literal notranslate"><span class="pre">SecondLevelModel</span></code> interface.</p>
<div class='alert alert-warning'>
    <b>ToDo</b> Alright then, one last ToDo! Suppose that we want to construct a group-level model that investigates the difference between the first-level "strongly_accept" contrast images from sub-001 and sub-003 (a nonsensical analysis for just two subjects, but just ignore that for now). Can you construct an appropriate second-level design matrix for this analysis? Store this design matrix (a <tt>DataFrame</tt>) in a variable called <tt>slm_dm_todo</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">slm_dm_todo</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">slm_dm_todo</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="concluding-remarks">
<h2>Concluding remarks<a class="headerlink" href="#concluding-remarks" title="Permalink to this headline">¶</a></h2>
<p>Hopefully this tutorial gave you an idea how to use Nilearn to run statistical models! We recommend you check out the ample excellent tutorials and examples on the Nilearn <a class="reference external" href="https://nilearn.github.io/">website</a> or to check out the codebase on <a class="reference external" href="https://github.com/nilearn/nilearn">Github</a>. As said before, Nilearn is a relatively novel project and its codebase may still change, so keep an eye out for new releases and extended functionality!</p>
<p>That said, we hope that this tutorial helps you to get started with your analyses using Nilearn.<br>
Happy hacking!</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./fMRI-introduction/week_7"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="nilearn.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">An introduction to Nilearn</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="../../fMRI-pattern-analysis/week_1/design_and_pattern_estimation.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Experimental design and pattern estimation</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Lukas Snoek<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>