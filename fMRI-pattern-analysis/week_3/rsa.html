
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Representational Similarity Analysis &#8212; NI-edu</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Bibliography" href="../../misc/bibliography.html" />
    <link rel="prev" title="Machine learning (“decoding”) analyses" href="../week_2/decoding_analyses.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/fmri.gif" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">NI-edu</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../index.html">
   Welcome to NI-edu
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/about.html">
   About this course
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started/installation.html">
   Installation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  fMRI-introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/1_python.html">
   Python for (f)MRI analysis
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../other/python_recap.html">
     Python recap
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_1/python_for_mri.html">
     Working with MRI data in Python (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/2_glm.html">
   Using the GLM to model fMRI data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_2/glm_part1_estimation.html">
     The GLM: estimation (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_3/glm_part2_inference.html">
     The GLM: inference (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/3_design_of_experiments_T.html">
   Design of experiments
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_3/design_of_experiments.html">
     Design of experiments (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_3/neurodesign.html">
     Neurodesign (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/4_preprocessing.html">
   Preprocessing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_4/temporal_preprocessing.html">
     Temporal preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_4/spatial_preprocessing.html">
     Spatial preprocessing (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_4/fmriprep.html">
     Fmriprep (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/5_multilevel.html">
   First &amp; run-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_5/linux_and_the_command_line.html">
     Linux and the CMD (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_5/first_level_analyses.html">
     First level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_5/run_level_analyses.html">
     Run-level analyses (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/6_grouplevel.html">
   Group-level analyses
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_6/group_level_analyses.html">
     Group-level analyses (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_6/MCC.html">
     Multiple comparison correction (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_6/ROI_analysis.html">
     ROI analysis (T)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../section_intros/7_nilearn.html">
   Introduction to Nilearn
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_7/nilearn.html">
     Introduction to Nilearn (T)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../fMRI-introduction/week_7/nilearn_stats.html">
     Statistics with Nilearn (T)
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  fMRI-pattern-analysis
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../week_1/design_and_pattern_estimation.html">
   Design and pattern estimation (T)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../week_2/decoding_analyses.html">
   Machine learning/decoding (T)
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Representational Similarity Analysis (T)
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Misc
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/bibliography.html">
   Bibliography
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/for_educators.html">
   For educators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONTRIBUTING.html">
   Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../misc/CONDUCT.html">
   Code of Conduct
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/fMRI-pattern-analysis/week_3/rsa.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/lukassnoek/NI-edu"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/lukassnoek/NI-edu/issues/new?title=Issue%20on%20page%20%2FfMRI-pattern-analysis/week_3/rsa.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/lukassnoek/NI-edu/edit/master/NI-edu/fMRI-pattern-analysis/week_3/rsa.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/lukassnoek/NI-edu/master?urlpath=tree/NI-edu/fMRI-pattern-analysis/week_3/rsa.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        <a class="jupyterhub-button" href="https://neuroimaging.lukas-snoek.com/hub/user-redirect/git-pull?repo=https://github.com/lukassnoek/NI-edu&urlpath=tree/NI-edu/NI-edu/fMRI-pattern-analysis/week_3/rsa.ipynb&branch=master"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch JupyterHub" data-toggle="tooltip"
                data-placement="left"><img class="jupyterhub-button-logo"
                    src="../../_static/images/logo_jupyterhub.svg"
                    alt="Interact on JupyterHub">JupyterHub</button></a>
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loading-in-the-data">
   Loading in the data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preprocessing">
   Preprocessing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multivariate-noise-normalization">
     Multivariate noise normalization
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#neural-rdms">
   Neural RDMs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exploratory-analysis-using-mds">
   Exploratory analysis using MDS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#categorical-rdms">
   Categorical RDMs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#continuous-computational-rdms">
   Continuous/computational RDMs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#testing-rdms">
   Testing RDMs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#correlation-based-tests">
     Correlation-based tests
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#reweighting-rdvs">
     Reweighting RDVs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#group-level-analyses">
     Group-level analyses
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="representational-similarity-analysis">
<h1>Representational Similarity Analysis<a class="headerlink" href="#representational-similarity-analysis" title="Permalink to this headline">¶</a></h1>
<p>This week’s tutorial is about Representational Similarity Analysis (RSA)! We’ll be looking at how to transform patterns into RDMs using various distance measures, how to test the relation between “feature RDMs” and “brain RDMs”, and take a look at exploratory RDM visualization using multidimensional-scaling (MDS).</p>
<p><strong>What you’ll learn</strong>: At the end of this tutorial, you …</p>
<ul class="simple">
<li><p>know you to preprocess patterns for RSA</p></li>
<li><p>understand the concept of an RDM and how it can be computed</p></li>
<li><p>can list different types of candidate RDMs and their differences</p></li>
<li><p>are able to test the association between candidate and neural RDMs</p></li>
</ul>
<p><strong>Estimated time needed to complete</strong>: 8-12 hours</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Some imports for the rest of the tutorial</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">nilearn</span> <span class="kn">import</span> <span class="n">image</span><span class="p">,</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">plotting</span><span class="p">,</span> <span class="n">masking</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="loading-in-the-data">
<h2>Loading in the data<a class="headerlink" href="#loading-in-the-data" title="Permalink to this headline">¶</a></h2>
<p>In this notebook, we are going to work with real data straightaway! Like in the previous decoding tutorial, we’ll work only with the data from a single run, though. In addition, to not use too much RAM, we’ll analyze only the data from an specific ROI. In contrast to last week, we are going to use a “functional ROI” based on the localizer data from our “flocBLOCKED” task. To derive a functional ROI, we already computed (for each subject) multiple contrasts and the associated whole-brain <span class="math notranslate nohighlight">\(z\)</span>-score maps in both subject “native” space (<em>T1w</em>) and standard space (<em>MNI152NLin2009cAsym</em>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">),</span> <span class="s1">&#39;NI-edu-data&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Downloading ROIs for all subjects (+- ... MB) ...&quot;</span><span class="p">)</span>
<span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds003477 <span class="o">{</span>data_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;derivatives/floc/*&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">floc_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;floc&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-03&#39;</span><span class="p">,</span> <span class="s1">&#39;rois&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have the following maps:</span><span class="se">\n</span><span class="s2">-&quot;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">floc_dir</span><span class="p">))))</span>
</pre></div>
</div>
</div>
</div>
<p>These maps have been computed using a “condition &gt; other conditions”. We are, of course, going to use the “face &gt; (place, character, body, object)” map for our ROI and use the data in MNI space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">floc_roi</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">floc_dir</span><span class="p">,</span> <span class="s1">&#39;sub-03_task-flocBLOCKED_space-MNI152NLin2009cAsym_desc-face_zscore.nii.gz&#39;</span><span class="p">)</span>

<span class="c1"># Let&#39;s plot the unthresholded map as well</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_stat_map</span><span class="p">(</span><span class="n">floc_roi</span><span class="p">,</span> <span class="n">cut_coords</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see in the plot above, this subject shows a strong response to faces (relative to other conditions) in right temporal lobe, just where you’d expect to find the fusiform face area (FFA). But to derive an ROI from this map, we should somehow binarize this image. While this choice is somewhat arbitrary, let’s threshold this map at <span class="math notranslate nohighlight">\(z &gt; 3\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">floc_roi_bin</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">math_img</span><span class="p">(</span><span class="s1">&#39;(img &gt; 3).astype(int)&#39;</span><span class="p">,</span> <span class="n">img</span> <span class="o">=</span> <span class="n">floc_roi</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_roi</span><span class="p">(</span><span class="n">floc_roi_bin</span><span class="p">,</span> <span class="n">cut_coords</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<p>The current ROI, however, contains <em>a lot</em> of voxels, also many far outside the location of where we’d expect the FFA. One “trick” we can use to further restrict the number of voxels is to constrain our functional ROI to a particular anatomical location. Here, we’ll pick the right temporal ocipital fusiform (rTOF):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ho_atlas</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_atlas_harvard_oxford</span><span class="p">(</span><span class="s1">&#39;cort-maxprob-thr25-2mm&#39;</span><span class="p">,</span> <span class="n">symmetric_split</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ho_map</span> <span class="o">=</span> <span class="n">ho_atlas</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span>
<span class="n">rTOF_idx</span> <span class="o">=</span> <span class="n">ho_atlas</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Right Temporal Occipital Fusiform Cortex&#39;</span><span class="p">)</span>
<span class="n">rTOF_roi</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">((</span><span class="n">ho_map</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span> <span class="o">==</span> <span class="n">rTOF_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">ho_map</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_roi</span><span class="p">(</span><span class="n">rTOF_roi</span><span class="p">,</span> <span class="n">cut_coords</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the anatomical ROI has a slightly higher spatial resolution (2 mm<span class="math notranslate nohighlight">\(^2\)</span>, instead of <span class="math notranslate nohighlight">\(2.7 \times 2.7 \times 2.97\)</span>). As such, we need to resample the anatomical mask to our functional resolution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rTOF_roi_resamp</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">resample_to_img</span><span class="p">(</span><span class="n">rTOF_roi</span><span class="p">,</span> <span class="n">floc_roi_bin</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can intersect the two masks using the <code class="docutils literal notranslate"><span class="pre">intersect_masks</span></code> from the Nilearn <code class="docutils literal notranslate"><span class="pre">masking</span></code> module:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setting the threshold to 1 means: only select voxels that are in *both* masks</span>
<span class="n">ffa_mask</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">intersect_masks</span><span class="p">((</span><span class="n">floc_roi_bin</span><span class="p">,</span> <span class="n">rTOF_roi_resamp</span><span class="p">),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">plot_roi</span><span class="p">(</span><span class="n">ffa_mask</span><span class="p">,</span> <span class="n">cut_coords</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="o">-</span><span class="mi">46</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<p>Alright, now let’s download the patterns from sub-03, run 1 (if not downloaded already):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Download the patterns (if not done already)</span>
<span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds003477 <span class="o">{</span>data_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;derivatives/pattern_estimation/sub-03/ses-1/patterns/*&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>… and load them in:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">patterns_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;pattern_estimation&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-03&#39;</span><span class="p">,</span> <span class="s1">&#39;ses-1&#39;</span><span class="p">,</span> <span class="s1">&#39;patterns&#39;</span><span class="p">)</span>
<span class="n">betas_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">patterns_dir</span><span class="p">,</span> <span class="s1">&#39;sub-03_ses-1_task-face_run-1_space-MNI152NLin2009cAsym_desc-trial_beta.nii.gz&#39;</span><span class="p">)</span>

<span class="c1"># Load 4D array and immediately mask it</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">betas_path</span><span class="p">,</span> <span class="n">ffa_mask</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of R:&quot;</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Voxels&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Samples (trials)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\mathbf</span><span class="si">{R}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Lastly, we need some experimental variable(s) to relate to this brain pattern. For convenience, we included the events file in the same directory as the estimated (variance of the) patterns:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">events_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">patterns_dir</span><span class="p">,</span> <span class="s1">&#39;sub-03_ses-1_task-face_run-1_events.tsv&#39;</span><span class="p">)</span>
<span class="n">events_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">events_file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Let&#39;s remove the rating/response events</span>
<span class="c1"># The .query method is great for filtering!</span>
<span class="n">events_df</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;trial_type != &#39;rating&#39; and trial_type != &#39;response&#39;&quot;</span><span class="p">)</span>
<span class="n">events_df</span>
</pre></div>
</div>
</div>
</div>
<p>There are many different experimental features that we’d could use for our analysis, but for now, we’ll stick with a single categorical (binary) one: face sex (“male” or “female”).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">events_df</span><span class="p">[</span><span class="s1">&#39;face_sex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): For our analysis, we'll need the labels ($S$) in numeric format. Convert the string labels ("male", "female") to a numeric format (male: 1, female: 0) and store the result in a variable called <tt>S_num</tt> (which should be a numpy array).
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_str2num</span>
<span class="n">test_str2num</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_num</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="preprocessing">
<h2>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this headline">¶</a></h2>
<p>In terms of preprocessing, there are a couple of things that you need to keep in mind when planning to use representational similarity analyses. First, while standardization (ensuring zero mean and unit standard deviation for each brain feature) is a common preprocessing step in decoding analyses, it is somewhat of a controversial for RSA (see e.g. <a class="reference external" href="https://www.frontiersin.org/articles/10.3389/fnins.2013.00174/full">this article</a>). As such, we are not going to apply standardization to our data.</p>
<div class="section" id="multivariate-noise-normalization">
<h3>Multivariate noise normalization<a class="headerlink" href="#multivariate-noise-normalization" title="Permalink to this headline">¶</a></h3>
<p>In week 1, we discussed univariate noise normalization, i.e., dividing each brain feature’s activity estimate (<span class="math notranslate nohighlight">\(\hat{\beta}\)</span>) by the standard deviation of the noise (<span class="math notranslate nohighlight">\(\hat{\sigma}\)</span>), which allows you to “downweigh” noisy voxels. Specifically for RSA, some people use <em>multivariate</em> noise normalization, which additionally incorporates the noise <em>covariance</em> between voxels. Like the temporal “uncorrelation” method we discussed in week 1, multivariate noise normalization effectively uncorrelates the data, yet this time in the <em>spatial</em> dimension. One often-cited reason for multivariate noise normalization in representational similarity analyses is that some distance metrics (discussed later) assume that the brain feature (e.g., voxels) of the data are independent.</p>
<p>So, before going on, let’s first load in the residuals from run 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, let&#39;s download them!</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Downloading residuals for ses-1, run-1, sub-03 (+- ... MB) ...&quot;</span><span class="p">)</span>
<span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds003477 <span class="o">{</span>data_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;derivatives/pattern_estimation/sub-03/ses-1/model/*task-face*run-1*residuals.nii.gz&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model_dir</span> <span class="o">=</span> <span class="n">patterns_dir</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;patterns&#39;</span><span class="p">,</span> <span class="s1">&#39;model&#39;</span><span class="p">)</span>
<span class="n">resids_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">model_dir</span><span class="p">,</span> <span class="s1">&#39;sub-03_ses-1_task-face_run-1_space-MNI152NLin2009cAsym_desc-model_residuals.nii.gz&#39;</span><span class="p">)</span>
<span class="c1"># We immediately apply the FFA mask to the residuals</span>
<span class="n">resids</span> <span class="o">=</span> <span class="n">masking</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">resids_path</span><span class="p">,</span> <span class="n">ffa_mask</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of masked residuals (TxK):&quot;</span><span class="p">,</span> <span class="n">resids</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In week 1, we computed the voxelwise noise standard deviation by simply called the numpy <code class="docutils literal notranslate"><span class="pre">std</span></code> function (or method) on our time axis:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">noise_std</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Voxel&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\hat{\sigma}$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">noise_std</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>However, we can also get the voxelwise noise standard deviation by computing the noise variance-covariance matrix and extracting the (square root of the) diagonal, because the diagonal represents the variance of the voxels (the “covariance with itself”, so to say).</p>
<p>Let’s first compute the covariance matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We need to transpose (.T) the residuals,</span>
<span class="c1"># otherwise we&#39;d get a TxT covariance matrix</span>
<span class="n">noise_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">resids</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Noise covariance matrix&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Voxels&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voxels&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Just to convince you that the (square root of the) diagonal is the same as the standard deviation we computed earlier:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise_std_from_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">noise_std</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">noise_std_from_cov</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;tab:orange&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voxel&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voxel&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\hat{\sigma}$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The reason we need the variance-covariance matrix is that for <em>multivariate</em> noise normalization, we use the <em>full</em> matrix, i.e., including the off-diagonal elements (the covariance between voxels). To do so, we first need to compute the <em>whitening</em> matrix, which is often denoted by <span class="math notranslate nohighlight">\(D\)</span> and is computed by taking the square root of the inverse of the estimated variance-covariance matrix (<span class="math notranslate nohighlight">\(\hat{\Sigma}\)</span>):</p>
<p>\begin{align}
D = \hat{\Sigma}^{-\frac{1}{2}}
\end{align}</p>
<p>Whitening using this particular whitening matrix (<span class="math notranslate nohighlight">\(\hat{\Sigma}^{-\frac{1}{2}}\)</span>) is also called <a class="reference external" href="https://en.wikipedia.org/wiki/Whitening_transformation">ZCA or Mahalanobis whitening</a>. To apply this whitening matrix to our patterns (<span class="math notranslate nohighlight">\(\mathbf{R}\)</span>), we simply take the dot product between the patterns and the whitening matrix:</p>
<p>\begin{align}
R_{\mathrm{mnn}} = RD
\end{align}</p>
<p>where <span class="math notranslate nohighlight">\(R_{\mathrm{mnn}}\)</span> is the multivariate noise normalized pattern matrix. Note that this operation is <em>very</em> similar to the temporal uncorrelation method, but instead of uncorrelating the trials (i.e., the rows of the pattern matrix), it uncorrelates the brain features (i.e., the columns of the pattern matrix).</p>
<p>Let’s first compute the whitening matrix. We can use the matrix square root function <code class="docutils literal notranslate"><span class="pre">sqrtm</span></code> from the <code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code> package:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># square root of inv = ^(-1/2)</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">sqrtm</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">noise_cov</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>And to get the multivariate noise normalized patterns, we compute the dot product:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">R_mnn</span> <span class="o">=</span> <span class="n">R</span> <span class="o">@</span> <span class="n">D</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s visualize the unnormalized, univariate noise normalized, and multivariate noise normalized patterns:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">R_unn</span> <span class="o">=</span> <span class="n">R</span> <span class="o">/</span> <span class="n">noise_std</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;No normalization&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">R_unn</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;UNN&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">R_mnn</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;MNN&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Voxels&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Trials&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Here, our patterns consist of only 64 voxels. Often, however, you might want to use patterns with (many) more voxels. For multivariate noise normalization, which uses the full <span class="math notranslate nohighlight">\(K \times K\)</span> variance-covariance matrix, using more brain features (<span class="math notranslate nohighlight">\(K\)</span>) than samples (<span class="math notranslate nohighlight">\(N\)</span>) often lead to a very unstable variance-covariance matrix (or in technical terms, a matrix that is not “positive semidefinite”). One trick that makes the variance-covariance matrix estimation more stable is to apply <em>regularization</em> (sometimes called “shrinkage”). This regularization will “shrink” the matrix more towards the identity matrix (<span class="math notranslate nohighlight">\(I\)</span>, i.e., a matrix with all zeros except the diagonal, which contains ones) when the ratio between brain features and samples becomes larger.<br></p>
<p>One such shrinkage method is the “Ledoit-Wolf” covariance estimator. Below, we import this function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.covariance</span> <span class="kn">import</span> <span class="n">ledoit_wolf</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): Read through the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.covariance.ledoit_wolf.html#sklearn.covariance.ledoit_wolf">documentation of the ledoit_wolf function</a> and then use it to compute the regularized covariance matrix of our pattern matrix and subsequently use this to multivariate noise normalize our pattern matrix. Store the result in a new variable called <tt>R_mnn_reg</tt>.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>
<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the ToDo above. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_ledoit_wolf</span>    
<span class="n">test_ledoit_wolf</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">R_mnn_reg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="neural-rdms">
<h2>Neural RDMs<a class="headerlink" href="#neural-rdms" title="Permalink to this headline">¶</a></h2>
<p>The first step in a representational similarity analysis is to create a “neural representational dissimilarity matrix” (RDM). This matrix is a symmetric <span class="math notranslate nohighlight">\(N \times N\)</span> matrix which represents how “dissimilar” patterns of different samples (i.e., rows in your pattern matrix, <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>). Note that the samples could be trials (e.g., “face 1”, “face 2”, “face 3”, etc.) but could also be conditions (e.g., “faces”, “houses”, “objects”, etc.). In our case, we’re focusing on trials.</p>
<p>For example, suppose we have only data from four trials (i.e., four rows in our pattern matrix <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>). A corresponding <span class="math notranslate nohighlight">\(4\times 4\)</span> RDM could like the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># some made up RDM</span>
<span class="n">example_rdm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">5.2</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">7.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">4.7</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">5.2</span><span class="p">,</span> <span class="mf">4.7</span><span class="p">,</span> <span class="mf">6.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">example_rdm</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Trials&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Trials&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Example RDM&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Dissimilarity&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In this example RDM, each cell represents a particular distance between two patterns. For example, the cell in the bottom left corner represents the dissimilarity between trial 1 and trial 4. Note that the RDM is symmetric, because the dissimilarity between trial 1 and 4 is the same as trial 4 and 1; also, the cells on the diagonal are all zero, as they represent the distance between a particular pattern and itself, which is zero!  Note that these two properties (symmetricity, zero diagonal) are only true when you compute your RDM on trials within the same run (unlike the between-run pattern distances, discussed previously).</p>
<p>For now, we’ll stick with within-run RDMs (as they’re a little easier to compute).</p>
<p>In a way, you can think about RDMs as “inverse” correlation matrices in which cells do not represent correlations (a kind of <em>similarity</em> metric) but distances.</p>
<p>By now, you might ask youself: “but how do you actually compute these dissimilarities?” Well, this depends on what <em>distance metric</em> you use! There are many different functions you can use to quantify the dissimilarity between two vectors (i.e., two rows in our pattern matrix). Actually, reflecting the intuition that an RDM is basically the inverse of a correlation matrix, one metric that is sometimes used is the <span class="math notranslate nohighlight">\(1-r\)</span> distance*. This distance simply quantifies distance as the 1 minus the correlation between two patterns. For example, the <span class="math notranslate nohighlight">\(1-r\)</span> distance between “pattern A” and “pattern B” is <span class="math notranslate nohighlight">\(1-\mathrm{corr(pattern\ A, pattern\ B})\)</span>.</p>
<hr class="docutils" />
<p>* In the RSA literature, some people use the <em>cosine distance</em>, which is the angle between two vectors; when the patterns are mean centered (i.e., the rows in <span class="math notranslate nohighlight">\(\mathbf{R}\)</span> have a mean of 0), this is exactly the same as the <span class="math notranslate nohighlight">\(1-r\)</span> distance!</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): For our data (the variable <tt>R</tt>), compute the RDM using the $1 -r$ distance and store it in a variable named <tt>rdm_1minr</tt>. Note: no need for a for-loop! (You might want to check out the <tt>np.corrcoef</tt> function.)
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_1minr</span>    
<span class="n">test_1minr</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">rdm_1minr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Another often-used distance metric used for RDMs, and perhaps the most intuitive one, is the Euclidean distance. This distance is computed as the square root of the sum of squared distances between two patterns (e.g., <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>) consisting of <span class="math notranslate nohighlight">\(K\)</span> elements:</p>
<p>\begin{align}
\delta_{euclidean} = \sqrt{\sum_{j=1}^{K}{(p_{j} - q_{j})^{2}}}
\end{align}</p>
<p>Below, we define two example patterns with four features and compute the Euclidean distance between them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># No need for a for loop!</span>
<span class="n">euc_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Euclidean distance between p and q:&quot;</span><span class="p">,</span> <span class="n">euc_dist</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 points): While all pairwise distances were easy to calculate using the $1-r$ distance, it takes a little more code to do this using the Euclidean distance. Compute the RDM based on the Euclidean distance for our data (the variable <tt>R</tt>) and store this in a variable named <tt>rdm_euc</tt>. Also visualize the RDM using the pyplot <tt>imshow</tt> function. Unless you're a linear algebra wizard, you need to use for loops to compute the RDM. Do not use any external functions (beyond numpy). Hint: pre-allocate your RDM first and then fill it cell by cell in a nested for loop.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">euclidean_distances</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">euclidean_distances</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">rdm_euc</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As you might have seen in the test cell, scikit-learn actually provides several functions to quickly compute distance matrices (RDMs) using various distance metrics. We recommend using the generic <code class="docutils literal notranslate"><span class="pre">pairwise_distances</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">pairwise_distances</span>
</pre></div>
</div>
</div>
</div>
<p>To compute an <span class="math notranslate nohighlight">\(N\times N\)</span> distance matrix from a <span class="math notranslate nohighlight">\(N\times K\)</span> pattern array (<span class="math notranslate nohighlight">\(\mathbf{R}\)</span>), you can use it as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rdm</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;name_of_metric&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, to compute an RDM based on the “cosine” distance (which is similar to the <span class="math notranslate nohighlight">\(1-r\)</span> distance), you can run:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rdm_cosine</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rdm_cosine</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Trials&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Trials&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Cosine-based RDM&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cosine distance&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Note that there is no agreed-upon “best” distance metric! If you want to know more about the different (dis)similarity metrics for pattern analyses, check out <a class="reference external" href="https://link.springer.com/article/10.1007/s42113-019-00068-5">this article</a>.</p>
<p>For the next couple of sections, we’ll use the Euclidean distance-based RDM:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rdm_R</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (1 point): Euclidean and $1-r$/cosine distances differ in one major aspect related to the "type" of information they can encode/pick up. What do you think this is?
</div><p>YOUR ANSWER HERE</p>
</div>
<div class="section" id="exploratory-analysis-using-mds">
<h2>Exploratory analysis using MDS<a class="headerlink" href="#exploratory-analysis-using-mds" title="Permalink to this headline">¶</a></h2>
<p>Most applications of RSA involve relating <em>neural</em> RDMs with RDMs based on experimental features (which we’ll discuss in the next section). However, you can also do exploratory analyses on your neural RDM only! This is usually done by investigating the (dis)similarity structure (or “representational geometry” in RSA terms), usually in a 2D or 3D space.</p>
<p>As pattern analyses are often applied to very high-dimensional data (i.e., patterns with many brain features, <span class="math notranslate nohighlight">\(K\)</span>), people often project the data (i.e., the patterns) into a lower dimensional space. We already encountered one such method in week 1: PCA! However, when interested in the (dis)similarity structure of your data, <em>multidimensional scaling</em> (MDS) is more appropriate. Just like PCA, this technique aims to create combinations of features into a lower-dimensional subset of components, such that the high-dimensional distances are presented as much as possible in the lower-dimensional space. For example, if the distance between A and B is 436 in high-dimensional space (e.g., <span class="math notranslate nohighlight">\(K=500\)</span>), MDS tries to create a lower-dimensional space (usually 2 components) in which the distance between A and B is as close as possible to 436 (as well as all other distances between patterns).</p>
<p>Of course, scikit-learn contains an implementation of MDS that uses the familiar <code class="docutils literal notranslate"><span class="pre">fit</span></code>/<code class="docutils literal notranslate"><span class="pre">transform</span></code> methods. Importantly, it can take in a <span class="math notranslate nohighlight">\(N\times K\)</span> matrix (like our pattern matrix <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>) and compute the high-dimensional distance structure (i.e., the RDM) internally or you can give it your precomputed RDM. In the latter case, you need to initialize it with <code class="docutils literal notranslate"><span class="pre">dissimilarity='prepcomputed'</span></code>, which is what we’re going to do:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">MDS</span>
<span class="n">mds</span> <span class="o">=</span> <span class="n">MDS</span><span class="p">(</span><span class="n">dissimilarity</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then, we call the <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> method to compute lower-dimensional (<span class="math notranslate nohighlight">\(K=2\)</span>) representation of the data (which is, again, an <span class="math notranslate nohighlight">\(N \times K\)</span> array, but this time, <span class="math notranslate nohighlight">\(K=2\)</span>!):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mds_R</span> <span class="o">=</span> <span class="n">mds</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">rdm_R</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of mds_R:&quot;</span><span class="p">,</span> <span class="n">mds_R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">mds_R</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mds_R</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;MDS component 1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;MDS component 2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): Below, re-plot the MDS scatterplot, but this time, color the datapoints (i.e., the trial patterns) according to their trial onset (you can set the color of the points with <tt>c</tt> parameter in the <tt>scatter</tt> function), which you can extract from the <tt>events_df</tt> dataframe. This way, datapoints (i.e., patterns) with a similar onset have a similar hue.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (1 point): Which phenomenon (that we discussed before) is clearly visible in this low-dimensional embedding of the data? 
</div><p>YOUR ANSWER HERE</p>
<p>Instead of coloring the datapoints according to some experimental property/feature (such as onset), an even more potent way to visualize MDS-embeddings is to plot the actual images that correspond with the trial patterns (here: the faces shown to the subject)! This way, you may find patterns in the data that you might not have thought of!</p>
<p>However, in our opinion, the true strength of RSA lies in their ability to test hypotheses about complex representational structures using experimental features, which is discussed next.</p>
</div>
<div class="section" id="categorical-rdms">
<h2>Categorical RDMs<a class="headerlink" href="#categorical-rdms" title="Permalink to this headline">¶</a></h2>
<p>In most pattern analyses, we’d like to evaluate the (possibly) association between experimental features and brain patterns. In RSA, this is done by comparing neural RDMs (discussed in the previous sections) with RDMs based on experimental features. These experimental feature RDMs (let’s call them “feature RDMs”) are constructed in largely the same way as neural RDMs: by computing the pairwise distance between samples!</p>
<p>The experimental features (<span class="math notranslate nohighlight">\(P\)</span>) that you use for your feature RDM of course depend on your hypothesis! Importantly, unlike decoding models, RSA naturally handles high-dimensional feature spaces very well. Like neural RDMs, no matter how many features you use, you’ll always analyze the resulting <span class="math notranslate nohighlight">\(N\times N\)</span> RDM!</p>
<p>After constructing your feature RDM, you can test whether the “geometry” of your hypothesized feature space matches the geometry of your brain patterns. In other words, you test whether the pattern of distances is similar in your brain data and your experimental features. Technically, you can use <em>any</em> (set of) feature(s) that you believe match the geometry of the corresponding brain patterns. How to actually test this will be discussed in section 5.</p>
<p>In this section, we’ll focus on the most straightforward type of feature RDM: the categorical RDM. This RDM, basically, investigates whether patterns belonging to the same condition are more similar than patterns belonging to a different condition (note the similarity to decoding models). For example, we could hypothesize that the FFA represents face gender, which should accordingly lead to relatively small neural distances between images of the same face gender and relatively large neural distances between images of a different face gender. Before delving into how we should construct a corresponding feature RDM, let’s first define our experimental feature: face gender. In the first section, we already extracted this from the events file. Now, let’s convert it to a numeric format:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span>
<span class="n">face_gen</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Face gender, numeric:&quot;</span><span class="p">,</span> <span class="n">face_gen</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, to capture this feature into an RDM, we can construct an RDM with zeros in cells corresponding to trials with the same condition (both male or both female faces) and ones everywhere else, which capture the hypothesis that trials should have a smaller distance when they are of the same condition (0) than when they are of a different condition (1).</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (1 point): Create this face-gender RDM and store it in a variable named <tt>rdm_fg</tt>, an $N \times N$ numpy array. Do not use any external functions for this. 
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_rdm_fg</span>
<span class="n">test_rdm_fg</span><span class="p">(</span><span class="n">face_gen</span><span class="p">,</span> <span class="n">rdm_fg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Technically, to create this categorical RDM (with only two levels), you can also use the <code class="docutils literal notranslate"><span class="pre">pairwise_distances</span></code> function with the “manhattan” metric (the sum of <em>absolute</em> distances):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note the np.newaxis, which is needed because pairwise_distances</span>
<span class="c1"># assumes that the input is 2D</span>
<span class="n">rdm_fg_pd</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">face_gen</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;manhattan&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rdm_fg_pd</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Categorical RDM&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="continuous-computational-rdms">
<h2>Continuous/computational RDMs<a class="headerlink" href="#continuous-computational-rdms" title="Permalink to this headline">¶</a></h2>
<p>The categorical RDMs discussed in the previous section are the most simple implementation of feature RDMs, based on only a single categorical feature. RSA really shines, though, when relating more complex feature sets (sometimes called “feature spaces”) consisting of multiple (continuous) variables.</p>
<p>For example, for our data, we have subject-specific ratings of dominance, trustworthiness, and attractiveness for all of the faces shown to (the same) subjects. If we’d want to investigate whether a particular brain region represents these face properties (you might call them “<a class="reference external" href="https://www.sciencedirect.com/science/article/abs/pii/S0959438813000147">social judgements</a>), we could create a feature RDM base on these three features; in fact, we’ll do that below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sj</span> <span class="o">=</span> <span class="n">events_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;subject_dominance&#39;</span><span class="p">,</span> <span class="s1">&#39;subject_trustworthiness&#39;</span><span class="p">,</span> <span class="s1">&#39;subject_attractiveness&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="n">rdm_sj</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">sj</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rdm_sj</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Social judgements RDM&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Note though, that all information about the individual features (attractiveness, trustworthiness, and dominance) is lost in this RDM! The feature RDM should represent the geometry of the entire feature space, not the effects of the individual features on brain activity (although we discuss a technique that allows for this type of inference in the next section).</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 point): Note that as long as you can formalize your hypothesis into a feature matrix ($N \times P$), you can create an RDM from it (and test it with RSA)! Suppose that I believe that social judgements are not represented in a bipolar fashion (from very unattractive to very attractive, very untrustworthy to very trustworthy, etc.; like we assumed before) but in an unipolar fashion relative from the mean rating. For example, this would mean that a face with an attractiveness/trusworthiness/dominance rating of -4 would be represented in the same way as a face with a rating of 4 (assuming a mean rating of 0) Moreover, suppose I believe that this representation is quadratic, not linear. For example, a face with an attractiveness rating of 2 is four times as attractive as a face with an attractiveness rating of 1. Using the social judgement data (i.e., the <tt>sj</tt> variable), create an RDM that represents this hypothesis.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_rdm_sj2</span>
<span class="n">test_rdm_sj2</span><span class="p">(</span><span class="n">sj</span><span class="p">,</span> <span class="n">rdm_sj2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>RSA also lends itself very well for testing computational models, i.e., models that yield a (set of) feature(s) that were directly computed from the data. For example, in vision science, there are many computational models that yield a set of (visual) feature that are computed from the image directly (i.e., from the pixels). Again, as long as you can specify a set of features that embody your hypothesis, you can create an RDM from it!</p>
<p>In the next ToDo, you’re going to practice a bit to get into this “computational mindset” by applying a very simple (and theoretically meaningless) computational model to the face stimuli. In the current directory there is a subfolder <code class="docutils literal notranslate"><span class="pre">stim</span></code>, which contains all the stimuli from the first run:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">imgs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;stims&#39;</span><span class="p">,</span> <span class="s1">&#39;*.jpg&#39;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To load an image as a numpy array, we can use the <code class="docutils literal notranslate"><span class="pre">imageio</span></code> library. Note that the function returns a 3D numpy array, where the first two dimensions represent width and height, and the third dimension represents the three color channels (red, green, and blue).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">imageio</span>
<span class="n">example_stim</span> <span class="o">=</span> <span class="n">imageio</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of image data:&quot;</span><span class="p">,</span> <span class="n">example_stim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 points): Suppose that I have a very naive theory about color representation in the brain. Specifically, suppose that I think that a particular brain area simply represents stimuli according to their average redness, greenness, and blueness. In other words, I believe that stimuli with similar average red/green/blue values have similar brain patterns. For the forty stimuli from run 1, construct an RDM that represents this hypothesis and store it in a variable named <tt>rdm_rgb</tt> (a $40\times 40$ array). Use a Euclidean distance metric. Hint: before constructing your RDM, your feature matrix should be of shape $40 \times 3$.
</div><div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement your ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_rdm_rgb</span>    
<span class="n">test_rdm_rgb</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">rdm_rgb</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Just by eye, it’s difficult to judge whether the neural RDM contains a similar representational geometry as the feature RDMs we created earlier. Fortunately, we have statistics!</p>
</div>
<div class="section" id="testing-rdms">
<h2>Testing RDMs<a class="headerlink" href="#testing-rdms" title="Permalink to this headline">¶</a></h2>
<p>In this section, we’ll discuss how to evaluate the “fit” of feature RDMs.</p>
<div class="section" id="correlation-based-tests">
<h3>Correlation-based tests<a class="headerlink" href="#correlation-based-tests" title="Permalink to this headline">¶</a></h3>
<p>Alright, so now we got two RDMs: the feature RDM and the neural RDM. To evaluate to what extent the two RDMs share the same representational geometry, we can simply correlate them! Before doing so, we have to do one more thing: extract the lower (or upper) triangle of the RDM. This is because RDMs are symmetric: the values above and below the diagonal are exactly the same. If we used the entire (flattened) RDM, we’d “artifically” create twice as many datapoints (i.e. the pairwise dissimilarities) than there really are, which will inflate the significance of the correlation between the RDMs because of increased sample size. So, instead of using all <span class="math notranslate nohighlight">\(N\cdot N\)</span> pairwise differences from the RDM, we need to extract only the flattened <span class="math notranslate nohighlight">\(N\times (N-1)/2\)</span> pairwise dissimilarity values, the “representational dissimilarity vector” (RDV) if you will. This means that we do not include the diagonal!</p>
<p>Fortunately, there is a function that easily extracts the lower triangle of a square distance matrix: <code class="docutils literal notranslate"><span class="pre">squareform</span></code> (from the <code class="docutils literal notranslate"><span class="pre">scipy.spatial.distance</span></code> module):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>

<span class="c1"># Let&#39;s extract the RDV from our neural RDM</span>
<span class="n">rdv_R</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">rdm_R</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape rdv_R:&quot;</span><span class="p">,</span> <span class="n">rdv_R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-success'>
    <b>Tip</b>: Sometimes, an RDM might not be <em>exactly</em> symmetric due to floating point inaccuracies, which will give an error my trying to extract the lower triangle using <tt>squareform</tt>. To circumvent this, you can round the RDM values to, e.g., 5 decimals using the <tt>.round(decimals)</tt> array method.
</div><p>As you can see, the shape of the <code class="docutils literal notranslate"><span class="pre">rdv_R</span></code> is as expected: <span class="math notranslate nohighlight">\(40 \times (40-1) / 2 = 780\)</span>. Let’s do the same for the face-gender RDM we created earlier (<code class="docutils literal notranslate"><span class="pre">rdm_fg_pd</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rdv_fg</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">rdm_fg_pd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape rdv_fg:&quot;</span><span class="p">,</span> <span class="n">rdv_fg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Importantly, the correlation between feature and neural RDMs is often evaluated using a rank-based correlation metric. For continuous feature RDMs, this is usually the Spearman correlation, but for categorical feature RDMs (such as our face-gender RDM), often the “Kendall Tau <span class="math notranslate nohighlight">\(\alpha\)</span>” correlation is used, as it deals properly with tied ranks. Implementations of both correlations are available from the <code class="docutils literal notranslate"><span class="pre">scipy.stats</span></code> module. Here, we’ll use Kendall’s Tau <span class="math notranslate nohighlight">\(\alpha\)</span>, because our face-gender RDM is categorical:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kendalltau</span>
<span class="n">rdm_corr</span><span class="p">,</span> <span class="n">pval</span> <span class="o">=</span> <span class="n">kendalltau</span><span class="p">(</span><span class="n">rdv_fg</span><span class="p">,</span> <span class="n">rdv_R</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Correlation between RDMs (p-value): </span><span class="si">%.3f</span><span class="s2"> (</span><span class="si">%.3f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rdm_corr</span><span class="p">,</span> <span class="n">pval</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Given the slighly positive correlation between our face-gender RDM and the FFA RDM, this means that patterns related to trials with the same face gender are slightly less dissimilar than patterns related to trials with a different face gender!</p>
</div>
<div class="section" id="reweighting-rdvs">
<h3>Reweighting RDVs<a class="headerlink" href="#reweighting-rdvs" title="Permalink to this headline">¶</a></h3>
<p>One more advanced RSA technique is “reweighting”. This technique allows you to use multiple feature RDVs to explain your neural RDV. Essentially, you assume that the neural RDV can be approximated as a linear weighted sum of different feature RDVs. For example, for two feature RDVs (<span class="math notranslate nohighlight">\(\mathrm{RDV}_{S_{1}}\)</span> and <span class="math notranslate nohighlight">\(\mathrm{RDV}_{S_{2}}\)</span>):</p>
<p>\begin{align}
\mathrm{RDV}<em>{R} = \beta</em>{0} + \mathrm{RDV}<em>{S</em>{1}}\beta_{1} + \mathrm{RDV}<em>{S</em>{2}}\beta_{2} + \epsilon
\end{align}</p>
<p>You might recognize this formulation as a linear model (GLM) with the neural RDV as dependent variable and the feature RDVs as independent variables. Here, the parameters (<span class="math notranslate nohighlight">\(\beta\)</span>) represent the “reweighting” factors. This technique is very useful to disentangle the contributions of different (possibly correlated) feature spaces. Note that, often, a variant of ordinary least squares (OLS) is used to determine the parameters: non-negative least squares (NNLS), which forces the parameters to be positive (for details about why NNLS should be used, see <a class="reference external" href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003915">this article</a>, and more information about reweighting in general, see <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0028393215301998#bib5">this article</a>).</p>
<p>After the reweighted RDV (<span class="math notranslate nohighlight">\(\mathrm{RDV}_{S}\hat{\beta}\)</span>) is computed, it can again be evaluated using a (rank-based) correlation: <span class="math notranslate nohighlight">\(r(\mathrm{RDV}_{S}\hat{\beta}, \mathrm{RDV}_{R})\)</span>.</p>
<div class='alert alert-warning'>
    <b>ToDo</b> (2 points): Previously, we defined two different feature RDMs: one based on face-gender (<tt>rdm_fg</tt>) and another one based on social judgements (<tt>rdm_sj</tt>). While theoretically meaningless, perform a reweighting analysis with the two feature RDVs as independent variables (in addition to an intercept!) and the neural RDV (based on <tt>rdm_R</tt>) as dependent variable. You can use the <tt>nnls</tt> implementation from <tt>scipy.optimize</tt> to perform NNLS. Note that the <tt>nnls</tt> function returns two things &mdash; the first object is the array with parameters, and it takes two arguments: the design matrix (independent variables) and the dependent variable. Compute the Spearman correlation between the reweighted RDV and the neural RDV and store the result in a variable named <tt>corr_reweighted_analysis</tt>.
</div> <div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">spearmanr</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">nnls</span>

<span class="c1"># YOUR CODE HERE</span>
<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo. &#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">niedu.tests.nipa.week_3</span> <span class="kn">import</span> <span class="n">test_reweighting_todo</span>    
<span class="n">test_reweighting_todo</span><span class="p">(</span><span class="n">rdm_fg</span><span class="p">,</span> <span class="n">rdm_sj</span><span class="p">,</span> <span class="n">rdm_R</span><span class="p">,</span> <span class="n">corr_reweighted_analysis</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-info'>
    <b>ToThink</b> (2 points): Suppose that you have a very high-dimensional experimental feature space (e.g., $P=10,000$) and you decide, instead of using a single feature RDM, to use an individual RDM for each feature and analyze the neural RDM in with a reweighted analysis. Explain why, while this would guarantee amazing results, this is probably not a good idea and propose a practical solution.  
</div><p>YOUR ANSWER HERE</p>
</div>
<div class="section" id="group-level-analyses">
<h3>Group-level analyses<a class="headerlink" href="#group-level-analyses" title="Permalink to this headline">¶</a></h3>
<p>So far, we only analyzed a single subject. Often, you might want to analyze multiple subjects and perform inference on the group level. Just like we did with single-subject decoding model performance scores, we can test whether results are significant by testing them against chance-level (i.e., 0 when using correlations). For example, suppose I have the following subject-specific RDV correlations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rdv_corrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.00</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.07</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Just like we evaluated single-subject RDV correlations using a non-parameteric rank-based correlation (Spearman or Kendall’s Tau), it is common to use a non-parametric test for group-level analyses: the Wilcoxon signed-rank test:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">wilcoxon</span>
<span class="n">stat</span><span class="p">,</span> <span class="n">pval</span> <span class="o">=</span> <span class="n">wilcoxon</span><span class="p">(</span><span class="n">rdv_corrs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P-value:&quot;</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class='alert alert-warning'>
    <b>ToDo</b> (4 points): In this ToDo, you'll implement an RSA analysis from start to end (on 10 subjects) in which you investigate whether facial expression (smiling vs. neutral) is represented in the right temporal occipital fusiform. In the end, you should have 10 RDV correlations (stored in the pre-allocated <tt>rdv_corrs</tt> variable). We have written the start of the for-loop for you already. Within the loop, do the following:
<ul class="simple">
<li><p>Load in the events file as a DataFrame, extract the facial expression information (column: “expression”), convert it to a numeric format, and compute the corresponding feature RDM;</p></li>
<li><p>Load in the patterns and apply the previously defined rTOF mask (the variable <tt>rTOF_roi_resamp</tt>);</p></li>
<li><p>Compute the Kendall Tau correlation between the feature RDV and neural RDV and store this in the <tt>rdv_corrs</tt> array;</p></li>
<li><p>After the loop, compute the associated group-level p-value using the Wilcoxon signed-rank test and store this in a variable named <tt>pval</tt>.</p></li>
</ul>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Downloading patterns for all subjects (+- 820 MB) ...&quot;</span><span class="p">)</span>
<span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds003477 <span class="o">{</span>data_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;derivatives/pattern_estimation/sub*/ses-1/*task-face*run-1*space-MNI*&quot;</span>
<span class="o">!</span>aws s3 sync --no-sign-request s3://openneuro.org/ds003477 <span class="o">{</span>data_dir<span class="o">}</span> --exclude <span class="s2">&quot;*&quot;</span> --include <span class="s2">&quot;derivatives/pattern_estimation/sub*/ses-1/*task-face*run-1*.tsv&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Implement the ToDo here. &#39;&#39;&#39;</span>

<span class="c1"># We&#39;ll only analyze the first 10 subjects</span>
<span class="n">subs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>
               <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;pattern_estimation&#39;</span><span class="p">,</span> <span class="s1">&#39;sub-*&#39;</span><span class="p">))])</span>
<span class="n">subs</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>

<span class="c1"># Pre-allocate the correlation vector</span>
<span class="n">rdv_corrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subs</span><span class="p">))</span>

<span class="n">pattern_est_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="s1">&#39;pattern_estimation&#39;</span><span class="p">)</span>

<span class="c1"># Iterate over subjects (i = 0:9)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing </span><span class="si">%s</span><span class="s2"> ...&quot;</span> <span class="o">%</span> <span class="n">sub</span><span class="p">)</span>
    <span class="n">events_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pattern_est_dir</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;ses-1&#39;</span><span class="p">,</span> <span class="s1">&#39;patterns&#39;</span><span class="p">,</span> <span class="n">sub</span> <span class="o">+</span> <span class="s1">&#39;_ses-1_task-face_run-1_events.tsv&#39;</span><span class="p">)</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pattern_est_dir</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;ses-1&#39;</span><span class="p">,</span> <span class="s1">&#39;patterns&#39;</span><span class="p">,</span> <span class="n">sub</span> <span class="o">+</span> <span class="s1">&#39;_ses-1_task-face_run-1_space-MNI152NLin2009cAsym_desc-trial_beta.nii.gz&#39;</span><span class="p">)</span>
    <span class="c1"># YOUR CODE HERE</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo (part 1). &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_almost_equal</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mf">0.01328101</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01517032</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01950736</span><span class="p">,</span>  <span class="mf">0.01904201</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0036204</span> <span class="p">,</span>
              <span class="o">-</span><span class="mf">0.01989825</span><span class="p">,</span>  <span class="mf">0.03360738</span><span class="p">,</span>  <span class="mf">0.02309053</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00340634</span><span class="p">,</span>  <span class="mf">0.01325309</span><span class="p">]),</span>
    <span class="n">rdv_corrs</span><span class="p">,</span>
    <span class="n">decimal</span><span class="o">=</span><span class="mi">4</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39; Tests the above ToDo (part 1). &#39;&#39;&#39;</span>
<span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="mf">0.6953125</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Well done!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This notebook discussed the basics of representational similarity analysis. There are many more topics that we didn’t discuss (such as cross-validated distance metrics, noise ceilings, and comparing different feature RDMs).</p>
<p>For a more in-depth technical overview of RSA, we recommend the following article:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003553">Nili, H., Wingfield, C., Walther, A., Su, L., Marslen-Wilson, W., &amp; Kriegeskorte, N. (2014). A toolbox for representational similarity analysis. PLoS computational biology, 10(4).</a></p></li>
</ul>
<p>(Note that the paper introduces a MATLAB toolbox for RSA; while very much in development, the authors recently rewrote the toolbox as a <a class="reference external" href="https://github.com/rsagroup/pyrsa">Python package</a>).</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./fMRI-pattern-analysis/week_3"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="../week_2/decoding_analyses.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Machine learning (“decoding”) analyses</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="../../misc/bibliography.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Bibliography</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Lukas Snoek<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>